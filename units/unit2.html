<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Scale di Mokken</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../assets/styles.css">
</head>

<body>

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#teoria-classica-dei-test-e-analisi-della-scala-di-mokken" id="toc-teoria-classica-dei-test-e-analisi-della-scala-di-mokken" class="nav-link active" data-scroll-target="#teoria-classica-dei-test-e-analisi-della-scala-di-mokken">Teoria Classica dei Test e Analisi della Scala di Mokken</a></li>
  <li><a href="#analisi-delle-scale-di-mokken-e-item-politomici" id="toc-analisi-delle-scale-di-mokken-e-item-politomici" class="nav-link" data-scroll-target="#analisi-delle-scale-di-mokken-e-item-politomici">Analisi delle Scale di Mokken e Item Politomici</a></li>
  <li><a href="#laffidabilità-nei-test" id="toc-laffidabilità-nei-test" class="nav-link" data-scroll-target="#laffidabilità-nei-test">L’Affidabilità nei Test</a></li>
  <li><a href="#coefficienti-di-scalabilità-nelle-scale-mokken" id="toc-coefficienti-di-scalabilità-nelle-scale-mokken" class="nav-link" data-scroll-target="#coefficienti-di-scalabilità-nelle-scale-mokken">Coefficienti di Scalabilità nelle Scale Mokken</a></li>
  <li><a href="#gli-errori-standard-nei-coefficienti-di-scalabilità-delle-scale-mokken" id="toc-gli-errori-standard-nei-coefficienti-di-scalabilità-delle-scale-mokken" class="nav-link" data-scroll-target="#gli-errori-standard-nei-coefficienti-di-scalabilità-delle-scale-mokken">Gli Errori Standard nei Coefficienti di Scalabilità delle Scale Mokken</a></li>
  <li><a href="#procedura-di-selezione-automatica-degli-item" id="toc-procedura-di-selezione-automatica-degli-item" class="nav-link" data-scroll-target="#procedura-di-selezione-automatica-degli-item">Procedura di Selezione Automatica degli Item</a></li>
  <li><a href="#monotonicità" id="toc-monotonicità" class="nav-link" data-scroll-target="#monotonicità">Monotonicità</a></li>
  <li><a href="#ordinamento-invariante-degli-item" id="toc-ordinamento-invariante-degli-item" class="nav-link" data-scroll-target="#ordinamento-invariante-degli-item">Ordinamento Invariante degli Item</a></li>
  <li><a href="#dimensione-del-campione" id="toc-dimensione-del-campione" class="nav-link" data-scroll-target="#dimensione-del-campione">Dimensione del Campione</a></li>
  <li><a href="#il-contributo-della-msa-alla-validazione-dei-test" id="toc-il-contributo-della-msa-alla-validazione-dei-test" class="nav-link" data-scroll-target="#il-contributo-della-msa-alla-validazione-dei-test">Il Contributo della MSA alla Validazione dei Test</a></li>
  <li><a href="#critiche-alla-msa" id="toc-critiche-alla-msa" class="nav-link" data-scroll-target="#critiche-alla-msa">Critiche alla MSA</a></li>
  <li><a href="#considerazioni-conclusive" id="toc-considerazioni-conclusive" class="nav-link" data-scroll-target="#considerazioni-conclusive">Considerazioni Conclusive</a></li>
  <li><a href="#formule-di-calcolo" id="toc-formule-di-calcolo" class="nav-link" data-scroll-target="#formule-di-calcolo">Formule di Calcolo</a></li>
  <li><a href="#coefficienti-di-scalabilità-singoli-h_i-nello-scaling-di-mokken" id="toc-coefficienti-di-scalabilità-singoli-h_i-nello-scaling-di-mokken" class="nav-link" data-scroll-target="#coefficienti-di-scalabilità-singoli-h_i-nello-scaling-di-mokken">Coefficienti di Scalabilità Singoli (<span class="math inline">\(H_i\)</span>) nello Scaling di Mokken</a>
  <ul class="collapse">
  <li><a href="#formula-per-calcolare-h_i" id="toc-formula-per-calcolare-h_i" class="nav-link" data-scroll-target="#formula-per-calcolare-h_i">Formula per Calcolare <span class="math inline">\(H_i\)</span></a></li>
  <li><a href="#coefficiente-di-scalabilità-di-coppia-h_ij-nello-scaling-di-mokken" id="toc-coefficiente-di-scalabilità-di-coppia-h_ij-nello-scaling-di-mokken" class="nav-link" data-scroll-target="#coefficiente-di-scalabilità-di-coppia-h_ij-nello-scaling-di-mokken">Coefficiente di Scalabilità di Coppia ($ H_{ij} $) nello Scaling di Mokken</a></li>
  <li><a href="#formula-per-calcolare-h_ij" id="toc-formula-per-calcolare-h_ij" class="nav-link" data-scroll-target="#formula-per-calcolare-h_ij">Formula per Calcolare $ H_{ij} $</a></li>
  <li><a href="#coefficiente-di-scalabilità-per-lintero-test-h" id="toc-coefficiente-di-scalabilità-per-lintero-test-h" class="nav-link" data-scroll-target="#coefficiente-di-scalabilità-per-lintero-test-h">Coefficiente di Scalabilità per l’Intero Test ($ H $)</a></li>
  <li><a href="#monotonicità-nello-scaling-di-mokken" id="toc-monotonicità-nello-scaling-di-mokken" class="nav-link" data-scroll-target="#monotonicità-nello-scaling-di-mokken">Monotonicità nello Scaling di Mokken</a></li>
  <li><a href="#investigate-the-assumption-of-non-intersecting-isrfs-using-method-restscore" id="toc-investigate-the-assumption-of-non-intersecting-isrfs-using-method-restscore" class="nav-link" data-scroll-target="#investigate-the-assumption-of-non-intersecting-isrfs-using-method-restscore">Investigate the assumption of non-intersecting ISRFs using method restscore</a></li>
  <li><a href="#proprietà-dellordine-di-mokken" id="toc-proprietà-dellordine-di-mokken" class="nav-link" data-scroll-target="#proprietà-dellordine-di-mokken">Proprietà dell’ordine di Mokken</a></li>
  <li><a href="#indipendenza-locale" id="toc-indipendenza-locale" class="nav-link" data-scroll-target="#indipendenza-locale">Indipendenza Locale</a></li>
  <li><a href="#affidabilità" id="toc-affidabilità" class="nav-link" data-scroll-target="#affidabilità">Affidabilità</a></li>
  <li><a href="#automated-item-selection-procedure" id="toc-automated-item-selection-procedure" class="nav-link" data-scroll-target="#automated-item-selection-procedure">Automated Item Selection Procedure</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Scale di Mokken</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">suppressPackageStartupMessages</span>({</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">library</span>(mokken)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>L’Analisi delle Scale Mokken (MSA), così denominata in onore del matematico e scienziato politico olandese Robert J. Mokken, è un insieme di metodi utilizzati nell’ambito della Teoria Non Parametrica della Risposta agli Item (NIRT) per valutare l’adeguatezza dei dati ai suoi modelli.</p>
<p>Secondo la Teoria della Risposta agli Item (IRT), i costrutti psicologici sono latenti, ovvero non direttamente osservabili, e si manifestano attraverso le risposte ai test. Le reazioni dei partecipanti ai test (cioè, le risposte agli item) dipendono dalla posizione del rispondente su un continuum latente e riflettono il grado in cui i rispondenti possiedono il costrutto in esame.</p>
<p>È chiaro però che la relazione tra la posizione del rispondente su un continuum latente e le sue risposte agli item, a causa degli errori di misurazione, non è una relazione diretta. Il contributo dei modelli della NIRT è quelllo di fornire gli strumenti analitici necessari per esaminare la congruenza e la pertinenza degli item di un test con la variabile latente sottostante. In particolare, i modelli MSA, che sono modelli probabilistici basati su tratti latenti e, avendo una natura non parametrica, sono caratterizzati da presupposti meno restrittivi rispetto ai modelli IRT parametrici, possono essere usati nella validazione di strumenti di misura psicometrici e nell’ordinare rispondenti e item lungo una scala ordinale. I modelli MSA sono applicabili sia a item dicotomici che politomici.</p>
<section id="teoria-classica-dei-test-e-analisi-della-scala-di-mokken" class="level2">
<h2 class="anchored" data-anchor-id="teoria-classica-dei-test-e-analisi-della-scala-di-mokken">Teoria Classica dei Test e Analisi della Scala di Mokken</h2>
<p>Esaminiamo ora le somiglianze e le differenze tra la Teoria Classica dei Test (CTT) e l’Analisi della Scala di Mokken (MSA).</p>
<p>La CTT si basa su diverse assunzioni fondamentali: 1. I punteggi osservati sono la somma dei punteggi veri e dei punteggi di errore, con l’aspettativa che i punteggi di errore abbiano una media di zero su prove ripetute. 2. Non c’è correlazione tra i punteggi di errore e i punteggi veri. 3. I punteggi veri in un test non sono correlati ai punteggi di errore in un altro test. 4. I punteggi di errore in due test somministrati agli stessi soggetti sono non correlati.</p>
<p>Nella CTT, i punteggi grezzi totali sono considerati indicatori delle posizioni dei rispondenti sul continuum del tratto latente. La proporzione di item corretti (valore p) indica la facilità degli item, mentre la correlazione tra item e punteggio totale misura la discriminazione degli item. La CTT enfatizza l’importanza dell’affidabilità, definita come la correlazione tra i punteggi osservati su due forme parallele del test.</p>
<p>Confrontando la CTT con la MSA, troviamo alcune somiglianze nelle metodologie di calcolo degli indici di abilità delle persone e di difficoltà degli item. Nella MSA,</p>
<ul>
<li>il <em>coefficiente di scalabilità dell’item (Hi)</em> è analogo alle correlazioni corrette tra item e punteggio totale nella CTT;</li>
<li>il <em>coefficiente di scalabilità tra coppie di item (Hij)</em> nella MSA corrisponde alle correlazioni tra coppie di item nella CTT;</li>
<li>il <em>coefficiente di scalabilità complessivo (H)</em> nella MSA è paragonabile agli indici di discriminazione media degli item nella CTT.</li>
</ul>
<p>Tuttavia, una differenza fondamentale tra la MSA e la CTT risiede nella testabilità dei modelli. A differenza della CTT, i modelli MSA permettono di verificare empiricamente le loro assunzioni, come l’indipendenza locale, l’unidimensionalità e la monotonicità. Ad esempio, un coefficiente di scalabilità negativo nella MSA smentirebbe gli assiomi del Modello di Omogeneità Monotona (MHM). Questa capacità di testare empiricamente le sue assunzioni rende la MSA un modello particolarmente robusto e trasparente.</p>
<p>In conclusione, mentre la CTT fornisce un quadro teorico solido per la comprensione e l’interpretazione dei punteggi dei test, ma non fornisce direttamente gli strumenti statistici per testare le assunzioni del modello, la MSA offre un approccio testabile e più flessibile. La MSA di dimostra dunque particolarmente utile nell’analizzare la struttura dei dati dei test e nella valutazione della validità delle scale di misurazione. Queste caratteristiche rendono la MSA un complemento prezioso alla CTT nella pratica della misurazione psicologica.</p>
</section>
<section id="analisi-delle-scale-di-mokken-e-item-politomici" class="level2">
<h2 class="anchored" data-anchor-id="analisi-delle-scale-di-mokken-e-item-politomici">Analisi delle Scale di Mokken e Item Politomici</h2>
<p>La MSA è stata inizialmente sviluppata per item dicotomici. In seguito però è stata estesa da Molenaar (1982a, 1997) per includere anche gli item politomici. Questa estensione mantiene i principi fondamentali della MSA applicati agli item dicotomici, ma aggiunge alcune specificità legate alla natura degli item politomici.</p>
<p>Nel caso degli item politomici, come quelli usati nelle scale Likert, le assunzioni del modello MSA vengono esaminate non solo a livello dell’intero item, ma anche per ciascun “passaggio” o categoria di risposta. Prendendo come esempio un item Likert a cinque punti, che va da “fortemente d’accordo” a “fortemente in disaccordo”, ci sono quattro passaggi distinti, ognuno rappresentante una transizione tra due categorie consecutive.</p>
<p>Per ogni passaggio di un item politomico, si definisce una Funzione di Risposta del Passaggio dell’Item (ISRF), che descrive la probabilità di scegliere una specifica categoria di risposta in funzione del tratto latente θ. Le ISRF sono cruciali per comprendere come le diverse categorie di risposta si relazionino al tratto latente misurato dall’item.</p>
<p>Affinché il modello di omogeneità monotona sia valido per gli item politomici, è necessario che le probabilità di scegliere una categoria di risposta k o superiore aumentino monotonamente con l’aumento di θ. Questo implica che le categorie di risposta debbano essere ordinate in modo significativo, rappresentando livelli progressivamente più alti del tratto latente.</p>
<p>Un aspetto fondamentale nell’analisi di item politomici nella MSA è l’assunzione di monotonicità, che richiede che le ISRF siano funzioni crescenti in θ. In altre parole, man mano che il tratto latente aumenta, aumenta anche la probabilità che un individuo scelga categorie di risposta superiori.</p>
<p>In sintesi, l’estensione della MSA agli item politomici fornisce uno strumento potente per analizzare item con più categorie di risposta, consentendo una misurazione più dettagliata e sfumata del tratto latente. Questa estensione rende la MSA particolarmente adatta per applicazioni in cui si utilizzano scale di risposta con gradazioni multiple, come nei questionari di valutazione del benessere psicologico, nei sondaggi di opinione o nelle valutazioni educative. Attraverso l’analisi dei passaggi degli item, la MSA per item politomici permette una comprensione più approfondita di come gli individui interagiscano con le diverse opzioni di risposta e di come queste risposte riflettano i loro livelli sul tratto latente.</p>
</section>
<section id="laffidabilità-nei-test" class="level2">
<h2 class="anchored" data-anchor-id="laffidabilità-nei-test">L’Affidabilità nei Test</h2>
<p>L’affidabilità in ambito di test psicometrici si riferisce al grado in cui un test è esente da errori di misurazione. Si valuta tipicamente esaminando la stabilità dei punteggi ottenuti dagli esaminandi in diverse somministrazioni del test, sia nel tempo che attraverso forme parallele del test. L’idea di base è che, in assenza di cambiamenti nei punteggi veri degli esaminandi, ci si aspetterebbe una correlazione perfetta tra le diverse amministrazioni. Ogni deviazione da questa correlazione perfetta è attribuita all’influenza dell’errore di misurazione.</p>
<p>Tuttavia, ottenere misure di affidabilità attraverso forme parallele o ripetute somministrazioni nel tempo può essere impraticabile, a causa di problemi logistici e degli effetti di memoria o pratica. Pertanto, l’affidabilità è spesso stimata attraverso metodi che richiedono una singola somministrazione del test.</p>
<p>L’alfa di Cronbach è uno degli estimatori di affidabilità più utilizzati, sebbene presenti diverse limitazioni. In risposta a queste limitazioni, Mokken (1971) ha sviluppato un coefficiente di affidabilità non distorto, noto come ρ (rho) o statistica MS. Questo coefficiente presuppone la validità della doppia monotonicità, una supposizione piuttosto forte. Per affrontare alcune delle sfide associate alla statistica ρ, Van der Ark, Van der Palm e Sijtsma (2011) hanno proposto un altro indicatore di affidabilità chiamato Coefficiente di Affidabilità delle Classi Latenti (LCRC). Questo è uno stimatore non distorto dell’affidabilità dei punteggi dei test, le cui assunzioni sono meno stringenti rispetto alla statistica ρ, richiedendo solamente l’indipendenza locale. Questo rappresenta un vantaggio significativo del coefficiente LCRC rispetto al coefficiente ρ, poiché rende l’LCRC più applicabile e flessibile in una varietà di contesti di test.</p>
<p>In conclusione, la scelta del metodo più appropriato per stimare l’affidabilità dipende dalle caratteristiche specifiche del test e dalle esigenze di misurazione. Mentre l’alfa di Cronbach rimane uno standard ampiamente utilizzato, le alternative come il coefficiente ρ di Mokken e il LCRC offrono strumenti aggiuntivi e talvolta più adatti per valutare l’affidabilità, specialmente in situazioni dove le assunzioni dell’alfa di Cronbach non sono soddisfatte o quando si utilizzano modelli non parametrici come quelli proposti nell’Analisi delle Scale di Mokken.</p>
</section>
<section id="coefficienti-di-scalabilità-nelle-scale-mokken" class="level2">
<h2 class="anchored" data-anchor-id="coefficienti-di-scalabilità-nelle-scale-mokken">Coefficienti di Scalabilità nelle Scale Mokken</h2>
<p>I coefficienti di scalabilità nelle Scale Mokken, ovvero <span class="math inline">\(H\)</span>, <span class="math inline">\(H_i\)</span> e <span class="math inline">\(H_{ij}\)</span>, sono indici chiave utilizzati per valutare la qualità di una misurazione nell’Analisi delle Scale Mokken (MSA). Questi coefficienti misurano la coerenza e l’ordinamento degli item e dei punteggi complessivi su un continuum latente, indicando in che misura gli item formano una gerarchia e se i punteggi degli item sono ordinati consistentemente.</p>
<ul>
<li><p><strong>Coefficienti di Scalabilità Singoli (<span class="math inline">\(H_i\)</span>)</strong>: Indicano la qualità di ogni singolo item. Un valore elevato di <span class="math inline">\(H_i\)</span> significa che l’item ha una buona discriminazione e contribuisce efficacemente all’ordinamento degli esaminandi. Valori superiori a 0.30 sono generalmente considerati accettabili.</p></li>
<li><p><strong>Coefficienti di Scalabilità per Coppie di Item (<span class="math inline">\(H_{ij}\)</span>)</strong>: Misurano la coerenza tra coppie di item. Valori positivi indicano che la coppia di item è coerente con il modello di omogeneità monotona. Valori negativi possono suggerire multidimensionalità o non monotonicità.</p></li>
<li><p><strong>Coefficienti di Scalabilità per l’Intero Test (<span class="math inline">\(H\)</span>)</strong>: Questo indice valuta la qualità dell’intero test, indicando in che misura la struttura complessiva dei dati si avvicina a un modello di Guttman perfetto. Valori tra 0.30 e 0.40 indicano una scala debole, tra 0.40 e 0.50 una scala media e superiori a 0.50 una scala forte.</p></li>
</ul>
<p>Questi coefficienti vengono calcolati basandosi sul rapporto tra gli errori di Guttman osservati e quelli attesi. Un coefficiente di <span class="math inline">\(H\)</span> vicino a uno implica una perfetta conformità al modello di Guttman, mentre valori vicini a zero indicano la presenza di numerosi errori di Guttman.</p>
<p>La MSA consente di testare empiricamente se i dati si adattano al modello di omogeneità monotona, fornendo un quadro robusto per l’analisi degli item e dei punteggi dei test. I coefficienti di scalabilità offrono una guida per determinare la qualità e la coerenza degli item nel contesto di una scala unidimensionale. Sono particolarmente utili per identificare item che potrebbero essere ridondanti o non allineati con il tratto latente misurato.</p>
<p>Inoltre, i coefficienti di scalabilità forniscono informazioni preziose sulla validità di costrutto di una scala. Anche se una scala ha una forte discriminazione (indicata da valori elevati di <span class="math inline">\(H_i\)</span> e <span class="math inline">\(H\)</span>), potrebbe mancare di validità di costrutto se i suoi item misurano solo una porzione ristretta del costrutto. Allo stesso modo, valori elevati di <span class="math inline">\(H_{ij}\)</span> tra specifiche coppie di item possono suggerire che uno degli item nella coppia sia ridondante.</p>
<p>In sintesi, i coefficienti di scalabilità nelle Scale Mokken non solo valutano la precisione nell’ordinamento degli esaminandi e la qualità degli item, ma aiutano anche a comprendere meglio la struttura e la validità di una scala. Questi coefficienti, quindi, giocano un ruolo cruciale nella selezione e nell’analisi degli item in contesti di misurazione psicometrica, educativa e di ricerca.</p>
</section>
<section id="gli-errori-standard-nei-coefficienti-di-scalabilità-delle-scale-mokken" class="level2">
<h2 class="anchored" data-anchor-id="gli-errori-standard-nei-coefficienti-di-scalabilità-delle-scale-mokken">Gli Errori Standard nei Coefficienti di Scalabilità delle Scale Mokken</h2>
<p>Gli errori standard (SE) sono fondamentali per interpretare correttamente i coefficienti di scalabilità nelle scale Mokken. Questi errori standard tengono conto dell’incertezza delle stime. Se l’errore standard è grande rispetto al coefficiente stesso, ad esempio un SE di .08 per un coefficiente Hi di .30, è probabile che il valore reale del coefficiente nella popolazione sia inferiore a .30, suggerendo che gli item potrebbero non essere scalabili.</p>
<p>La dimensione dell’errore standard dipende da due fattori: la dimensione del campione e l’asimmetria delle distribuzioni dei punteggi degli item. Con un campione più grande, gli errori standard sono generalmente più piccoli, mentre distribuzioni dei punteggi più asimmetriche portano a errori standard più grandi. Tuttavia, un ampio campione non garantisce stime precise dei coefficienti di scalabilità.</p>
<p>Per i coefficienti di scalabilità, possiamo calcolare gli intervalli di confidenza al 95% (CI) usando la formula:</p>
<p><span class="math display">\[
\text{95% CI} = H_i \pm (1.96 \times \text{SE})
\]</span></p>
<p>Per esempio, se <span class="math inline">\(H_i\)</span> è .30 con un SE di .10, il CI sarà tra .10 e .50. Questo intervallo ampio implica che il valore reale di <span class="math inline">\(H_i\)</span>, con il 95% di confidenza, si trova in questo range, indicando una bassa affidabilità del coefficiente. Se <span class="math inline">\(H_i\)</span> è .15 con un SE di .10, il CI sarà tra -.05 e .35, suggerendo che il vero coefficiente potrebbe essere zero o anche negativo nella popolazione, e quindi l’item dovrebbe essere scartato.</p>
<p>Mokken (1971) ha indicato che la monotonicità delle funzioni di risposta all’item (IRF) per tutti gli item utilizzati nel calcolo del punteggio totale X+ è una condizione sufficiente per la loro utilità nella classificazione degli esaminandi. Di conseguenza, gli item con bassi coefficienti di scalabilità vengono generalmente scartati.</p>
<p>Tuttavia, Crișan e colleghi (2020) consigliano di non rimuovere item inadatti dalle scale se non vi sono altri argomenti (ad esempio, di contenuto) per farlo. I guadagni in affidabilità, selezione delle persone e validità predittiva potrebbero non compensare la perdita di copertura del costrutto e validità dei criteri. Pertanto, la decisione di mantenere o rimuovere item da una scala dovrebbe basarsi principalmente su considerazioni teoriche, e i ricercatori applicati dovrebbero essere cauti nel non utilizzare regole empiriche per eliminare item in modo acritico.</p>
<p>In sintesi, l’analisi degli errori standard nei coefficienti di scalabilità delle scale Mokken fornisce informazioni cruciali sulla affidabilità e la validità degli item della scala. Tuttavia, le decisioni su quali item mantenere o scartare dovrebbero essere prese considerando non solo gli aspetti psicometrici ma anche il contesto teorico e il contenuto della scala stessa.</p>
</section>
<section id="procedura-di-selezione-automatica-degli-item" class="level2">
<h2 class="anchored" data-anchor-id="procedura-di-selezione-automatica-degli-item">Procedura di Selezione Automatica degli Item</h2>
<p>La Procedura di Selezione Automatica degli Item (AISP) è una metodologia impiegata nella MSA per selezionare un insieme di item da un pool più ampio che aderiscano alle assunzioni del Modello di Mokken (MHM). L’AISP aiuta a esaminare l’unidimensionalità e identifica item non scalabili.</p>
<p>Una scala di Mokken si compone di una serie di item selezionati in base a due criteri specifici. Prima di tutto, ogni item deve avere una covarianza (<span class="math inline">\(H_{i}\)</span>) che superi un valore soglia (c), scelto dall’utente. Solitamente, si raccomanda di impostare questo valore soglia a c=.30. Il secondo criterio richiede che la covarianza tra ogni coppia di item (<span class="math inline">\(H_{ij}\)</span>) sia maggiore di zero. In sintesi, per essere inclusi in una scala di Mokken, gli item devono avere sia una covarianza individuale (<span class="math inline">\(H_{i}\)</span>) sia una covarianza reciproca (<span class="math inline">\(H_{ij}\)</span>) positive e superiori a un valore minimo predefinito.</p>
<p>Questo processo inizia selezionando due item con la più alta <span class="math inline">\(H_{ij}\)</span> e continua aggiungendo nuovi item che soddisfano i criteri. Se alcuni item non rispettano questi criteri, l’AISP tenta di costruire una seconda scala o li identifica come non scalabili.</p>
<p>Le scale costruite con l’AISP misurano un tratto latente comune, ordina in modo affidabile le persone e discriminano bene. Tuttavia, talvolta, un item può essere selezionato con un valore <span class="math inline">\(H_{i}\)</span> inferiore a c, contraddicendo la definizione di scala di Mokken. Questi item inadatti dovrebbero essere esclusi successivamente.</p>
<p>L’AISP può essere vista come un’alternativa più efficiente all’analisi fattoriale, in quanto non è influenzata dalle difficoltà degli item e può essere applicata sia a item dicotomici che politomici. Tuttavia, i ricercatori dovrebbero considerare la teoria sostanziale e non affidarsi solo alle soluzioni statistiche prodotte dal software.</p>
<p>È importante notare che la scelta del valore limite inferiore c influisce sulla struttura della scala identificata. Valori più alti di c possono portare al rifiuto di molti item e alla formazione di scale sostanzialmente prive di significato con pochi item. D’altra parte, valori bassi di c possono nascondere la vera dimensionalità dei dati includendo tutti gli item in una singola scala. Il valore scelto dovrebbe dipendere dall’obiettivo specifico della ricerca.</p>
<p>Inoltre, l’AISP è paragonabile all’analisi fattoriale esplorativa, ma a differenza dell’analisi fattoriale, l’AISP può concludere senza trovare una scala valida se tutti i valori di <span class="math inline">\(H_{ij}\)</span> sono inferiori a .30. Invece, l’analisi fattoriale trova sempre una soluzione, anche se non necessariamente significativa.</p>
<p>In conclusione, l’AISP è uno strumento utile per la costruzione di scale di Mokken, ma presenta limitazioni nella valutazione della dimensionalità. Gli studi di simulazione mostrano che questo metodo può essere meno efficiente rispetto ad altri metodi non parametrici nel rilevare la vera dimensionalità dei dati, soprattutto quando le dimensioni sono correlate o gli item saturano su più di una dimensione. Pertanto, i ricercatori dovrebbero utilizzare questo strumento con cautela e considerare un’ampia gamma di valori limite inferiori c per rivelare la vera struttura dei dati.</p>
</section>
<section id="monotonicità" class="level2">
<h2 class="anchored" data-anchor-id="monotonicità">Monotonicità</h2>
<p>La monotonicità, un concetto chiave nelle scale Mokken, si riferisce alla relazione tra la posizione di una persona su una variabile latente (una caratteristica o tratto non direttamente osservabile) e la sua probabilità di rispondere correttamente a un item (domanda o affermazione). In sostanza, man mano che una persona si sposta verso livelli più elevati sulla variabile latente, la sua probabilità di dare una risposta corretta dovrebbe aumentare o rimanere la stessa, ma non diminuire. Questo principio si applica sia agli item con due possibili risposte (dicotomici) sia a quelli con più risposte (politomici).</p>
<p>Per valutare la monotonicità, si utilizzano diversi metodi, tra cui l’analisi dei gruppi di restscore. Il “restscore” è il punteggio totale ottenuto da un individuo in un test, escludendo il punteggio dell’item specifico che si sta analizzando. Ad esempio, in un test di 10 item, se si vuole esaminare l’item numero 10, il restscore per ogni persona sarà il suo punteggio totale escludendo il punteggio ottenuto all’item 10. Di conseguenza, si creano diversi gruppi di restscore, che vanno da 0 a 9 in questo caso.</p>
<p>La relazione tra restscore e monotonicità è la seguente: nei grafici, i gruppi di restscore sono confrontati con la percentuale di persone che hanno risposto correttamente all’item in questione all’interno di ogni gruppo. Idealmente, al crescere del restscore, la percentuale di risposte corrette dovrebbe aumentare o rimanere costante. Se i gruppi di restscore sono piccoli e quindi non forniscono stime affidabili, possono essere combinati con gruppi adiacenti per ottenere dimensioni maggiori e stime più precise.</p>
<p>Il restscore funge da sostituto per θ, la posizione sulla variabile latente. Se la monotonicità è rispettata, ci si aspetta che la percentuale di risposte corrette aumenti (o almeno rimanga costante) man mano che aumenta il restscore. In altre parole, persone con un restscore più alto dovrebbero avere una probabilità maggiore di rispondere correttamente rispetto a quelle con un restscore più basso. Questa aspettativa dovrebbe essere valida per tutte le coppie di gruppi di restscore.</p>
<p>L’analisi delle Funzioni di Risposta all’Item (IRF) è particolarmente utile perché permette di osservare come la performance degli item varia lungo il continuum del tratto latente. A differenza dell’IRT parametrico, dove l’attenzione è sulla stima dei parametri, l’IRT non parametrico (NIRT) si concentra sui metodi grafici, che sono fondamentali per comprendere come gli item funzionino a diversi livelli del tratto latente.</p>
<p>Per gli item politomici, la monotonicità è valutata sia complessivamente sia all’interno delle singole categorie di risposta. Inoltre, si utilizzano i coefficienti di scalabilità per valutare la monotonicità. Se il Modello di Omoegeneità Monotona (MHM) è valido, le covarianze tra tutte le coppie di item (Hij) devono essere non negative. Tuttavia, Hij non negativi non sono una condizione sufficiente per garantire IRFs non decrescenti e non assicurano l’adattamento al MHM. Nella pratica, item con valori di Hi superiori a .30 sono generalmente considerati accettabili.</p>
</section>
<section id="ordinamento-invariante-degli-item" class="level2">
<h2 class="anchored" data-anchor-id="ordinamento-invariante-degli-item">Ordinamento Invariante degli Item</h2>
<p>In contesti psicologici ed educativi, la definizione della difficoltà degli item di un test è cruciale. Generalmente, questa difficoltà viene determinata attraverso le medie degli item nella popolazione target. Tuttavia, è importante considerare che l’ordine di difficoltà derivato dalle risposte medie della popolazione potrebbe non essere universale per ogni individuo.</p>
<p>Il concetto di Ordinamento Invariante degli Item (IIO) si riferisce alla necessità che l’ordine di difficoltà degli item rimanga consistente tra diversi sottogruppi di persone. Questo aspetto è fondamentale per garantire che i confronti tra i gruppi basati sui punteggi totali siano validi e che le differenze nei punteggi totali abbiano un significato reale. In ambito psicologico, ad esempio nei questionari sulla depressione o sull’ansia, l’IIO implica che un individuo con un punteggio totale più alto manifesti tutti i sintomi di una persona con un punteggio inferiore, oltre a sintomi aggiuntivi.</p>
<p>L’IIO è altresì desiderabile quando si ordinano gli item di un test da quelli più facili a quelli più difficili, per garantire che questa progressione sia valida per tutti gli esaminandi. In altre parole, un item considerato facile dovrebbe essere tale per tutti i partecipanti, così come un item difficile dovrebbe rappresentare una sfida per tutti.</p>
<p>Un ordinamento degli item che non rispetta l’IIO indica una variazione nella difficoltà degli item tra diversi gruppi. Questo può suggerire una funzione differenziale dell’item (DIF) o un bias, rendendo problematico ordinare gli item in base alla loro difficoltà.</p>
<p>Per valutare l’IIO, si utilizzano diverse tecniche come il metodo dei gruppi di restscore, il metodo di divisione degli item, le matrici delle proporzioni P(++)/P(–), e il metodo di divisione dei restscore. Queste procedure aiutano a determinare se l’ordine di difficoltà degli item è coerente attraverso diversi gruppi.</p>
<p>In conclusione, l’IIO è essenziale sia per la teoria della misurazione sia per l’interpretazione accurata dei punteggi dei test. Pur essendo un presupposto fondamentale nell’uso degli strumenti di misurazione, l’IIO spesso non viene verificato empiricamente. La sua conferma è particolarmente importante nei test che mirano a riflettere una struttura gerarchica o cumulativa dei tratti misurati. Per trarre conclusioni affidabili sui processi cognitivi evolutivi basati sull’ordine di difficoltà degli item, è cruciale dimostrare la validità dell’IIO.</p>
</section>
<section id="dimensione-del-campione" class="level2">
<h2 class="anchored" data-anchor-id="dimensione-del-campione">Dimensione del Campione</h2>
<p>Nel campo della psicometria, determinare la dimensione minima di un campione per i test statistici è un’area ben stabilita. Tuttavia, per quanto riguarda l’Analisi delle Scale Mokken (MSA), questo è un ambito ancora poco esplorato e ci sono pochi studi a riguardo. La ricerca in questo settore è necessaria per evitare sia la capitalizzazione sul caso sia l’utilizzo di campioni eccessivamente grandi, specialmente quando le risorse e il tempo a disposizione dei ricercatori sono limitati.</p>
<p>La “capitalizzazione sul caso” si riferisce a una condizione in cui una scala di Mokken viene identificata casualmente quando, in realtà, tale scala non esiste e ciò è dovuto alla ridotta dimensione del campione. Al contrario, può anche accadere che una scala esistente non venga identificata.</p>
<p>Uno studio condotto da Straat et al.&nbsp;(2014) ha esaminato le dimensioni minime del campione necessarie per l’Automated Item Selection Procedure (AISP) e per l’algoritmo genetico (GA). Lo studio ha valutato l’impatto di diversi fattori, inclusa la lunghezza del test, i valori approssimativi dei coefficienti di scalabilità (Hi) degli item e la correlazione tra le dimensioni nella scala. I risultati hanno evidenziato che la dimensione del campione necessaria dipende da tutti questi fattori. Tuttavia, il fattore più influente è risultato essere il valore di Hi. Con l’aumento di Hi, erano necessarie dimensioni di campione più piccole per assegnare correttamente gli item alle scale appropriate. La lunghezza del test non ha avuto un grande impatto sulla precisione della classificazione degli item nelle scale corrette. Tuttavia, le correlazioni tra le dimensioni hanno avuto qualche effetto in combinazione con vari livelli di Hi. Per valori di Hi intorno a .22, sono necessarie dimensioni di campione di 750-1000 persone per ottenere una precisione mediocre o adeguata, e di 1250-2500 persone per una precisione buona o eccellente. Con valori di Hi di .42, per una precisione mediocre o adeguata sono necessarie dimensioni di campione di 50 persone, mentre per una precisione buona o eccellente, la dimensione del campione dovrebbe essere di almeno 250. Quando le correlazioni tra le due dimensioni erano alte (ad esempio, .60) e i valori di Hi erano .42, erano necessarie dimensioni di campione maggiori per assegnare correttamente gli item alle scale rispetto alla condizione in cui le correlazioni erano .30 o 1.</p>
<p>Un altro studio condotto da Watson et al.&nbsp;(2018) ha indagato l’impatto della dimensione del campione sui coefficienti di scalabilità utilizzando dati reali. Hanno estratto campioni di 50, 250, 500, 600, 750 e 1000 persone da un campione più ampio di 7510 persone che hanno risposto a un questionario di 14 item con item a 5 punti Likert. Utilizzando il bootstrapping, hanno estratto 1000 campioni per ogni dimensione del campione. I risultati hanno mostrato che i valori medi di H e Hi non cambiavano notevolmente tra le diverse dimensioni del campione. Tuttavia, considerando gli intervalli di confidenza al 95%, dimensioni di campione più piccole hanno portato a un maggior numero di occasioni in cui il limite inferiore degli intervalli di confidenza al 95% per Hi era inferiore a .30. Ad esempio, per N=50, il numero di volte in cui il limite inferiore degli intervalli di confidenza per Hi era inferiore a .30 era 592, mentre per N=1000, questo numero era zero. Ciò significa che, basandosi sugli errori standard di Hi, quando N=50, in 592 casi su 1000 si dovrebbe rifiutare l’item, concludendo che il suo Hi potrebbe essere inferiore a .30. Tuttavia, i valori medi di Hi per N=50 e N=1000 erano esattamente gli stessi. Questo suggerisce che la dimensione del campione non influisce sulle stime puntuali dei coefficienti di scalabilità, ma gioca un ruolo cruciale quando si considerano gli errori standard dei coefficienti di scalabilità e gli intervalli di confidenza per decidere sulla qualità degli item.</p>
<p>In conclusione, questi studi evidenziano l’importanza di considerare la dimensione del campione nell’analisi delle Scale Mokken. Mentre i valori medi di scalabilità possono non variare significativamente con la dimensione del campione, la precisione e l’affidabilità delle stime, così come la capacità di trarre conclusioni affidabili sulla qualità degli item, sono influenzate dalla grandezza del campione. Pertanto, è fondamentale scegliere una dimensione di campione adeguata per garantire risultati validi e affidabili nelle scale di Mokken. Questo è particolarmente critico in situazioni dove risorse e tempo sono limitati, e una scelta accurata della dimensione del campione può contribuire a un utilizzo più efficiente di tali risorse.</p>
</section>
<section id="il-contributo-della-msa-alla-validazione-dei-test" class="level2">
<h2 class="anchored" data-anchor-id="il-contributo-della-msa-alla-validazione-dei-test">Il Contributo della MSA alla Validazione dei Test</h2>
<p>Nell’ambito dell’Analisi delle Scale Mokken (MSA), la validità del modello di omogeneità monotona è cruciale. Questo modello è confermato quando le assunzioni fondamentali di unidimensionalità, monotonicità e indipendenza locale sono rispettate. In particolare, se i coefficienti di scalabilità H, Hi e Hij risultano positivi e significativamente superiori a zero (o meglio ancora, superiori a .30), ciò indica che i dati si conformano efficacemente a una struttura di Guttman. Tale conformità fornisce una forte indicazione dell’esistenza di un costrutto unidimensionale.</p>
<p>L’adeguamento al modello di omogeneità monotona implica inoltre la presenza di monotonicità. Ciò significa che deve esistere una relazione non decrescente tra la variabile latente θ e la probabilità di ottenere una risposta corretta. Questo concetto è perfettamente in linea con il secondo criterio di validità nell’approccio basato sugli strumenti, secondo il quale variazioni nel tratto latente dovrebbero produrre variazioni corrispondenti nelle risposte agli item.</p>
<p>Un’ulteriore dimensione della MSA è il modello di doppia monotonicità, che introduce l’assunzione dell’Ordinamento Invariante degli Item (IIO). Secondo questa assunzione, le Funzioni di Risposta all’Item (IRF) degli item di un test non dovrebbero intersecarsi. Anche se una sua violazione non rende di per sé un test invalido secondo l’approccio basato sugli strumenti, la conformità all’IIO migliora notevolmente l’interpretabilità dei punteggi del test. Inoltre, la violazione dell’IIO è analoga alla presenza di funzione differenziale dell’item (DIF) nei modelli IRT parametrici.</p>
<p>In conclusione, la MSA si rivela uno strumento estremamente utile e potente per la validazione di test in ambiti psicologici ed educativi. La capacità della MSA di confermare il modello di omogeneità monotona attraverso i coefficienti di scalabilità offre una valida evidenza che i test misurano effettivamente il costrutto unidimensionale che intendono valutare. Questo aspetto è fondamentale per garantire che i punteggi dei test riflettano veramente le capacità o le caratteristiche misurate.</p>
<p>L’incorporazione dell’Ordinamento Invariante degli Item (IIO) nel modello di doppia monotonicità aggiunge un ulteriore livello di rigorosità. Assicurandosi che le IRF degli item non si intersechino, si aumenta la precisione con cui il test misura il costrutto e si migliora l’interpretazione dei punteggi. Questo approccio riduce il rischio di bias e garantisce che il test sia equamente rappresentativo per tutti i partecipanti, indipendentemente dalle loro caratteristiche individuali.</p>
<p>Inoltre, la MSA fornisce una base solida per affermare che le variazioni nei punteggi dei test sono effettivamente causate da variazioni nel costrutto misurato. Questa caratteristica rende la MSA particolarmente preziosa in contesti dove è essenziale dimostrare una relazione causale tra il costrutto e i punteggi del test.</p>
<p>In sintesi, l’impiego della MSA nella validazione dei test non solo rafforza la fiducia nella precisione e nell’affidabilità dei test stessi, ma contribuisce anche a una maggiore chiarezza e trasparenza nell’interpretazione dei risultati.</p>
</section>
<section id="critiche-alla-msa" class="level2">
<h2 class="anchored" data-anchor-id="critiche-alla-msa">Critiche alla MSA</h2>
<p>Negli anni ’80, l’Analisi delle Scale Mokken (MSA) è stata criticata per la limitata applicabilità del coefficiente di scalabilità H, ritenuto dipendente dalle caratteristiche del campione e degli item, e non adeguato come misura di adattamento del modello. Ulteriori critiche hanno riguardato il coefficiente di scalabilità degli item Hi, accusato di selezionare solo item con IRF ripide e distanti, escludendo item validi e riducendo la varianza e l’affidabilità del test. I critici hanno anche messo in dubbio l’adeguatezza della MSA per l’ordinamento libero degli item secondo il rango latente, suggerendo una possibile necessità del modello di Rasch.</p>
<p>In risposta, i difensori della MSA hanno sottolineato che le critiche si basano su una lettura selettiva e una mancata comprensione dei modelli non parametrici. Hanno ribadito che H e Hi sono intesi come misure dell’omogeneità monotona, e non come indici di doppia monotonia, e che la dipendenza di H dalla varianza della popolazione è in linea con le assunzioni del modello. Questo dibattito evidenzia l’importanza di valutare attentamente i metodi statistici come la MSA nel loro contesto di applicazione.</p>
</section>
<section id="considerazioni-conclusive" class="level2">
<h2 class="anchored" data-anchor-id="considerazioni-conclusive">Considerazioni Conclusive</h2>
<p>In questo capitolo, abbiamo esplorato una questione fondamentale nella misurazione psicologica: l’efficacia dei punteggi totali grezzi nell’ordinare gli esaminandi. Tradizionalmente, tali punteggi vengono utilizzati per classificare i soggetti, da quelli più competenti a quelli meno competenti, da quelli più ansiosi a quelli meno ansiosi, o da quelli più depressi a quelli meno depressi. Sebbene sia comunemente accettato che i punteggi grezzi siano dati su scala ordinale, molti ricercatori li trattano come se fossero su scala intervallo. Ciò significa che, utilizzando i punteggi grezzi, si può solamente stabilire l’ordine dei rispondenti, ma non discernere le differenze tra di loro.</p>
<p>Il tema principale affrontato in questo capitolo è che i punteggi grezzi potrebbero non essere nemmeno dati ordinali. In altre parole, i punteggi totali grezzi potrebbero non essere sufficientemente affidabili per ordinare gli esaminandi. Affinché i punteggi grezzi siano considerati ordinali, i pattern di risposta devono adattarsi al Modello di Omogeneità Monotona (MHM). Nella teoria classica dei test, si assume che i punteggi totali siano ordinali senza verificarlo. Il MHM, come modello IRT non parametrico, ci permette di testare se i punteggi totali rispettano l’assioma di una scala ordinale. Lo stesso vale per gli item: l’adattamento al Modello di Doppia Monotonicità (DMM) ci permette di ordinare gli item in base alle loro proporzioni di risposte corrette (valore p).</p>
<p>In questo capitolo, abbiamo discusso le procedure conosciute collettivamente come Analisi delle Scale Mokken, per testare l’adattamento dei dati al MHM e al DMM. Queste analisi offrono strumenti preziosi per verificare l’affidabilità e la validità dei punteggi totali grezzi utilizzati in una vasta gamma di contesti psicologici.</p>
</section>
<section id="formule-di-calcolo" class="level2">
<h2 class="anchored" data-anchor-id="formule-di-calcolo">Formule di Calcolo</h2>
<p>Per sviluppare un’intuizione più precisa dello scaling di Mokken, consideriamo nei dettagli il calcolo di alcuni dei suoi indici fondamentali.</p>
</section>
<section id="coefficienti-di-scalabilità-singoli-h_i-nello-scaling-di-mokken" class="level2">
<h2 class="anchored" data-anchor-id="coefficienti-di-scalabilità-singoli-h_i-nello-scaling-di-mokken">Coefficienti di Scalabilità Singoli (<span class="math inline">\(H_i\)</span>) nello Scaling di Mokken</h2>
<p>Esaminiamo il coefficiente di scalabilità singolo, denotato come <span class="math inline">\(H_i\)</span>, il quale misura la qualità di un singolo item in uno scaling di Mokken. Un valore elevato di <span class="math inline">\(H_i\)</span> indica che l’item discrimina bene tra gli esaminandi e contribuisce efficacemente all’ordinamento degli stessi.</p>
<p>Le soglie generalmente accettate per i coefficienti di scalabilità singoli (<span class="math inline">\(H_i\)</span>) sono le seguenti:</p>
<ul>
<li><strong><span class="math inline">\(H_i \geq 0.30\)</span></strong>: Considerato accettabile. L’item discrimina abbastanza bene e contribuisce all’ordinamento degli esaminandi.</li>
<li><strong><span class="math inline">\(H_i \geq 0.40\)</span></strong>: Considerato buono. L’item ha una buona capacità di discriminazione.</li>
<li><strong><span class="math inline">\(H_i \geq 0.50\)</span></strong>: Considerato molto buono. L’item ha un’ottima capacità di discriminazione.</li>
</ul>
<section id="formula-per-calcolare-h_i" class="level3">
<h3 class="anchored" data-anchor-id="formula-per-calcolare-h_i">Formula per Calcolare <span class="math inline">\(H_i\)</span></h3>
<p>La formula per calcolare il coefficiente di scalabilità singolo <span class="math inline">\(H_i\)</span> di un item <span class="math inline">\(i\)</span> è:</p>
<p><span class="math display">\[
H_i = \frac{ \sum_{j \neq i} H_{ij} }{ n - 1 },
\]</span></p>
<p>dove <span class="math inline">\(H_{ij}\)</span> è il coefficiente di scalabilità di coppia tra l’item <span class="math inline">\(i\)</span> e l’item <span class="math inline">\(j\)</span>, e <span class="math inline">\(n\)</span> è il numero totale di item. Il coefficiente di scalabilità di coppia <span class="math inline">\(H_{ij}\)</span> è definito come:</p>
<p><span class="math display">\[
H_{ij} = \frac{ \text{cov}(X_i, X_j) }{ \text{min} [\text{var}(X_i), \text{var}(X_j)] },
\]</span></p>
<p>dove: - <span class="math inline">\(X_i\)</span> e <span class="math inline">\(X_j\)</span> sono le risposte agli item <span class="math inline">\(i\)</span> e <span class="math inline">\(j\)</span>. - <span class="math inline">\(\text{cov}(X_i, X_j)\)</span> è la covarianza tra gli item <span class="math inline">\(i\)</span> e <span class="math inline">\(j\)</span>. - <span class="math inline">\(\text{var}(X_i)\)</span> e <span class="math inline">\(\text{var}(X_j)\)</span> sono le varianze degli item <span class="math inline">\(i\)</span> e <span class="math inline">\(j\)</span>.</p>
<p>Intuitivamente, <span class="math inline">\(H_i\)</span> misura quanto bene l’item <span class="math inline">\(i\)</span> contribuisce all’ordine totale degli esaminandi basato sui punteggi totali. Se un item ha un <span class="math inline">\(H_i\)</span> elevato, significa che le risposte a questo item sono ben correlate con le risposte agli altri item, suggerendo che discrimina efficacemente tra esaminandi con punteggi diversi.</p>
<p>Per calcolare i coefficienti di scalabilità singoli <span class="math inline">\(H_i\)</span> in R, possiamo utilizzare il pacchetto <code>mokken</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mokken)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Consideriamo un set di dati relativi all’Adjective Checklist (ACL), che consiste of 300 adjectives and adjectival phrases commonly used to describe a person’s personality. Consideriamo la sottoscala Communality.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(acl)   </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>Communality <span class="ot">&lt;-</span> acl[,<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>Communality <span class="sc">|&gt;</span> <span class="fu">head</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>     reliable honest unscrupulous* deceitful* unintelligent* obnoxious*
[1,]        3      3             2          4              4          4
[2,]        2      4             4          3              3          4
[3,]        2      3             3          3              3          3
[4,]        3      2             2          2              2          2
[5,]        3      4             3          4              3          3
[6,]        3      3             3          2              3          3
     thankless* unfriendly* dependable cruel*
[1,]          4           4          3      4
[2,]          1           3          4      4
[3,]          4           3          3      4
[4,]          3           2          3      4
[5,]          4           4          3      4
[6,]          3           3          4      4</code></pre>
</div>
</div>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>scalability <span class="ot">&lt;-</span> <span class="fu">coefH</span>(Communality)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in check.data(X): Varying numbers of item scores were observed across the items.
  Either the items have the same number of response categories but some item categories were not endorsed;
  or the items have
      different numbers of categories by design. 
  In the latter case, the sum score cannot be used for (ordinal) measurement.</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>$Hij
               reliable se      honest  se      unscrupulous* se     
reliable                         0.528  (0.052)  0.242        (0.068)
honest          0.528   (0.052)                  0.250        (0.071)
unscrupulous*   0.242   (0.068)  0.250  (0.071)                      
deceitful*      0.331   (0.055)  0.282  (0.057)  0.343        (0.059)
unintelligent*  0.132   (0.057)  0.139  (0.055)  0.145        (0.060)
obnoxious*      0.273   (0.059)  0.162  (0.057)  0.239        (0.053)
thankless*      0.183   (0.056)  0.160  (0.058)  0.121        (0.051)
unfriendly*     0.247   (0.061)  0.192  (0.074)  0.241        (0.063)
dependable      0.717   (0.046)  0.552  (0.054)  0.229        (0.066)
cruel*          0.116   (0.069)  0.141  (0.080)  0.291        (0.061)
               deceitful* se      unintelligent* se      obnoxious* se     
reliable        0.331     (0.055)  0.132         (0.057)  0.273     (0.059)
honest          0.282     (0.057)  0.139         (0.055)  0.162     (0.057)
unscrupulous*   0.343     (0.059)  0.145         (0.060)  0.239     (0.053)
deceitful*                         0.102         (0.053)  0.321     (0.050)
unintelligent*  0.102     (0.053)                         0.201     (0.051)
obnoxious*      0.321     (0.050)  0.201         (0.051)                   
thankless*      0.336     (0.054)  0.133         (0.051)  0.339     (0.052)
unfriendly*     0.399     (0.053)  0.112         (0.056)  0.407     (0.052)
dependable      0.317     (0.053)  0.077         (0.059)  0.253     (0.058)
cruel*          0.423     (0.055)  0.005         (0.055)  0.372     (0.061)
               thankless* se      unfriendly* se      dependable se     
reliable        0.183     (0.056)  0.247      (0.061)  0.717     (0.046)
honest          0.160     (0.058)  0.192      (0.074)  0.552     (0.054)
unscrupulous*   0.121     (0.051)  0.241      (0.063)  0.229     (0.066)
deceitful*      0.336     (0.054)  0.399      (0.053)  0.317     (0.053)
unintelligent*  0.133     (0.051)  0.112      (0.056)  0.077     (0.059)
obnoxious*      0.339     (0.052)  0.407      (0.052)  0.253     (0.058)
thankless*                         0.430      (0.056)  0.227     (0.061)
unfriendly*     0.430     (0.056)                      0.254     (0.053)
dependable      0.227     (0.061)  0.254      (0.053)                   
cruel*          0.267     (0.066)  0.430      (0.065)  0.118     (0.077)
               cruel*  se     
reliable        0.116  (0.069)
honest          0.141  (0.080)
unscrupulous*   0.291  (0.061)
deceitful*      0.423  (0.055)
unintelligent*  0.005  (0.055)
obnoxious*      0.372  (0.061)
thankless*      0.267  (0.066)
unfriendly*     0.430  (0.065)
dependable      0.118  (0.077)
cruel*                        

$Hi
               Item H  se     
reliable         0.304 (0.029)
honest           0.265 (0.034)
unscrupulous*    0.236 (0.034)
deceitful*       0.319 (0.028)
unintelligent*   0.116 (0.033)
obnoxious*       0.288 (0.028)
thankless*       0.245 (0.030)
unfriendly*      0.309 (0.032)
dependable       0.299 (0.032)
cruel*           0.252 (0.036)

$H
Scale H      se 
  0.264 (0.020) </code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>scalability<span class="sc">$</span>Hi</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>               Item H  se     
reliable         0.304 (0.029)
honest           0.265 (0.034)
unscrupulous*    0.236 (0.034)
deceitful*       0.319 (0.028)
unintelligent*   0.116 (0.033)
obnoxious*       0.288 (0.028)
thankless*       0.245 (0.030)
unfriendly*      0.309 (0.032)
dependable       0.299 (0.032)
cruel*           0.252 (0.036)</code></pre>
</div>
</div>
<p>In questo esempio, gli item con <span class="math inline">\(H_i\)</span> superiori a 0.30 sono considerati accettabili, indicando che questi item contribuiscono efficacemente all’ordinamento degli esaminandi.</p>
</section>
<section id="coefficiente-di-scalabilità-di-coppia-h_ij-nello-scaling-di-mokken" class="level3">
<h3 class="anchored" data-anchor-id="coefficiente-di-scalabilità-di-coppia-h_ij-nello-scaling-di-mokken">Coefficiente di Scalabilità di Coppia ($ H_{ij} $) nello Scaling di Mokken</h3>
<p>Il coefficiente di scalabilità di coppia <span class="math inline">\(H_{ij}\)</span> misura la qualità della relazione tra due item specifici all’interno di uno scaling di Mokken. Questo coefficiente è utile per valutare quanto bene due item discriminano insieme tra gli esaminandi.</p>
</section>
<section id="formula-per-calcolare-h_ij" class="level3">
<h3 class="anchored" data-anchor-id="formula-per-calcolare-h_ij">Formula per Calcolare $ H_{ij} $</h3>
<p>La formula per calcolare il coefficiente di scalabilità di coppia $ H_{ij} $ tra due item $ i $ e $ j $ è:</p>
<p><span class="math display">\[
H_{ij} = \frac{P(X_i = X_j) - P(X_i \neq X_j)}{1 - P(X_i \neq X_j)},
\]</span></p>
<p>dove: - $ P(X_i = X_j) $ è la probabilità che le risposte agli item $ i $ e $ j $ siano uguali. - $ P(X_i X_j) $ è la probabilità che le risposte agli item $ i $ e $ j $ siano diverse.</p>
<p>Intuitivamente, $ H_{ij} $ misura quanto bene i due item $ i $ e $ j $ lavorano insieme per discriminare tra gli esaminandi. Un valore elevato di $ H_{ij} $ indica che i due item hanno una buona covarianza e che la loro variabilità è tale da contribuire efficacemente all’ordinamento degli esaminandi.</p>
<p>Le soglie generalmente accettate per i coefficienti di scalabilità di coppia (<span class="math inline">\(H_{ij}\)</span>) sono le seguenti:</p>
<ul>
<li><strong><span class="math inline">\(H_{ij} \geq 0.30\)</span></strong>: Considerato accettabile. La coppia di item discrimina abbastanza bene insieme.</li>
<li><strong><span class="math inline">\(H_{ij} \geq 0.40\)</span></strong>: Considerato buono. La coppia di item ha una buona capacità di discriminazione congiunta.</li>
<li><strong><span class="math inline">\(H_{ij} \geq 0.50\)</span></strong>: Considerato molto buono. La coppia di item ha un’ottima capacità di discriminazione congiunta.</li>
</ul>
<p>Per calcolare i coefficienti di scalabilità di coppia $ H_{ij} $ in R, possiamo utilizzare nuovamente la funzione <code>coefH</code> del pacchetto <code>mokken</code>.</p>
<p>Nei dati dell’esempio precedente, $ H_{ij} $ per ciascuna coppia di item è riportato nella matrice.</p>
</section>
<section id="coefficiente-di-scalabilità-per-lintero-test-h" class="level3">
<h3 class="anchored" data-anchor-id="coefficiente-di-scalabilità-per-lintero-test-h">Coefficiente di Scalabilità per l’Intero Test ($ H $)</h3>
<p>Il coefficiente di scalabilità per l’intero test ($ H $) misura la qualità complessiva di un set di item in termini di capacità di discriminazione e di ordinamento degli esaminandi. Un valore elevato di $ H $ indica che il test, nel suo insieme, discrimina bene tra gli esaminandi.</p>
<p>La formula per calcolare il coefficiente di scalabilità per l’intero test è:</p>
<p><span class="math display">\[
H = \frac{\sum_{i &lt; j} H_{ij}}{\sum_{i &lt; j} H_{ij}^{\text{max}}} ,
\]</span></p>
<p>dove: - $ H_{ij} $ è il coefficiente di scalabilità di coppia tra gli item $ i $ e $ j $. - $ H_{ij}^{} $ è il massimo valore teorico di $ H_{ij} $.</p>
<p>Intuitivamente, $ H $ misura quanto bene l’intero set di item lavora insieme per discriminare tra gli esaminandi. Un valore elevato di $ H $ indica che, complessivamente, gli item hanno una buona capacità di discriminazione e contribuiscono efficacemente all’ordinamento degli esaminandi.</p>
<p>Le soglie comunemente utilizzate per interpretare $ H $ sono: - <strong>$ H <span class="math inline">\(**: Considerato accettabile.
- **\)</span> H <span class="math inline">\(**: Considerato buono.
- **\)</span> H $</strong>: Considerato molto buono.</p>
<p>Per calcolare il coefficiente di scalabilità per l’intero test ($ H $) in R, possiamo utilizzare nuovamente la funzione <code>coefH()</code> del pacchetto <code>mokken</code>.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualizzare il coefficiente di scalabilità per l'intero test</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>H_test <span class="ot">&lt;-</span> scalability<span class="sc">$</span>H</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(H_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Scale H      se 
  0.264 (0.020) </code></pre>
</div>
</div>
<p>Il valore del coefficiente di scalabilità per l’intero test ($ H $) di 0.264 indica che la qualità complessiva della sottoscala Communality è scarsa.</p>
</section>
<section id="monotonicità-nello-scaling-di-mokken" class="level3">
<h3 class="anchored" data-anchor-id="monotonicità-nello-scaling-di-mokken">Monotonicità nello Scaling di Mokken</h3>
<p>Nello scaling di Mokken, la monotonicità è una proprietà desiderabile che implica che la probabilità di rispondere correttamente a un item aumenta con il livello del tratto latente misurato dal test. In altre parole, per gli item di un test che misurano lo stesso costrutto, gli esaminandi con punteggi più alti sul tratto latente dovrebbero avere una probabilità maggiore di rispondere correttamente a ciascun item rispetto a quelli con punteggi più bassi.</p>
<p>La funzione <code>check.monotonicity()</code> del pacchetto <code>mokken</code> in R viene utilizzata per verificare la presenza di violazioni della monotonicità per ciascun item in un set di dati. Essa esamina se la relazione tra la probabilità di rispondere correttamente a un item e il livello del tratto latente è monotona crescente.</p>
<p>La funzione suddivide i punteggi totali degli esaminandi in gruppi (detti “gruppi di punteggio”, “restscore”) e verifica se la probabilità di rispondere correttamente a ciascun item aumenta con il punteggio del gruppo. Se la probabilità di risposta corretta diminuisce in uno o più gruppi, ciò costituisce una violazione della monotonicità.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>monotonicity_results <span class="ot">&lt;-</span> <span class="fu">check.monotonicity</span>(Communality)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in check.data(X): Varying numbers of item scores were observed across the items.
  Either the items have the same number of response categories but some item categories were not endorsed;
  or the items have
      different numbers of categories by design. 
  In the latter case, the sum score cannot be used for (ordinal) measurement.</code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(monotonicity_results)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>               ItemH #ac #vi #vi/#ac maxvi  sum sum/#ac zmax #zsig crit
reliable        0.30  15   0    0.00  0.00 0.00  0.0000 0.00     0    0
honest          0.27  16   0    0.00  0.00 0.00  0.0000 0.00     0    0
unscrupulous*   0.24  20   0    0.00  0.00 0.00  0.0000 0.00     0    0
deceitful*      0.32  22   0    0.00  0.00 0.00  0.0000 0.00     0    0
unintelligent*  0.12  20   1    0.05  0.07 0.07  0.0036 0.85     0   32
obnoxious*      0.29  19   0    0.00  0.00 0.00  0.0000 0.00     0    0
thankless*      0.25  17   0    0.00  0.00 0.00  0.0000 0.00     0    0
unfriendly*     0.31  19   0    0.00  0.00 0.00  0.0000 0.00     0    0
dependable      0.30  17   0    0.00  0.00 0.00  0.0000 0.00     0    0
cruel*          0.25  19   0    0.00  0.00 0.00  0.0000 0.00     0    0</code></pre>
</div>
</div>
<p>I risultati forniti dalla funzione <code>check.monotonicity()</code> includono:</p>
<ul>
<li><strong>Numero di violazioni</strong>: Il numero di violazioni della monotonicità per ciascun item.</li>
<li><strong>Indice di monotonicità</strong>: Un indice che indica la forza della monotonicità per ciascun item.</li>
</ul>
<p>La colonna <code>#vi</code> mostra il numero di violazioni della monotonicità per ciascun item.</p>
<p>Per avere una visione più chiara delle violazioni della monotonicità, è possibile creare dei grafici:</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Creare grafici delle violazioni di monotonicità</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(monotonicity_results)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-6-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-6-3.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-6-4.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-6-5.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-6-6.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-6-7.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-6-8.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-6-9.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-6-10.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>I grafici generati dalla funzione <code>check.monotonicity()</code> forniscono una rappresentazione visiva delle probabilità condizionali di rispondere correttamente a ciascun item rispetto ai punteggi totali degli esaminandi. I grafici generati dalla funzione <code>check.monotonicity()</code> nel pacchetto <code>mokken</code> per ciascun item mostrano due pannelli. Ecco come interpretarli:</p>
<p>Il pannello di sinistra mostra quattro spezzate che rappresentano la probabilità condizionale di rispondere correttamente all’item per ciascun gruppo di punteggio totale. Queste spezzate corrispondono ai seguenti concetti:</p>
<ol type="1">
<li><strong>E</strong>: La probabilità empirica di rispondere correttamente all’item per ciascun gruppo di punteggio.</li>
<li><strong>ER</strong>: La probabilità empirica di rispondere correttamente all’item dopo aver applicato una regressione non parametrica.</li>
<li><strong>M</strong>: La probabilità media di rispondere correttamente all’item.</li>
<li><strong>MR</strong>: La probabilità media di rispondere correttamente all’item dopo aver applicato una regressione non parametrica.</li>
</ol>
<p>Queste spezzate aiutano a visualizzare come la probabilità di rispondere correttamente all’item varia rispetto al punteggio totale degli esaminandi.</p>
<p>Il pannello di destra mostra una singola spezzata che rappresenta la probabilità media condizionale di rispondere correttamente all’item per ciascun gruppo di punteggio totale. Questa spezzata è utile per verificare visivamente la presenza di violazioni della monotonicità.</p>
<p>Interpretando correttamente queste linee, possiamo identificare eventuali violazioni della monotonicità e valutare la qualità degli item nel contesto dello scaling di Mokken.</p>
</section>
<section id="investigate-the-assumption-of-non-intersecting-isrfs-using-method-restscore" class="level3">
<h3 class="anchored" data-anchor-id="investigate-the-assumption-of-non-intersecting-isrfs-using-method-restscore">Investigate the assumption of non-intersecting ISRFs using method restscore</h3>
<p>La funzione <code>check.restscore()</code> è utilizzata per verificare la coerenza degli item rispetto al punteggio residuo. In pratica, controlla se ogni item in una scala di Mokken soddisfa i requisiti di monotonicità e se contribuisce positivamente alla scala nel suo complesso.</p>
<ul>
<li><strong>Monotonicità</strong>: La monotonicità si riferisce al fatto che la probabilità di rispondere correttamente a un item dovrebbe aumentare con l’aumento del punteggio totale del soggetto.</li>
<li><strong>Punteggio residuo</strong>: Il punteggio residuo per un item è calcolato sottraendo il punteggio dell’item dal punteggio totale del soggetto su tutti gli item della scala.</li>
</ul>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Investigate the assumption of non-intersecting ISRFs using method restscore</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>restscore.list <span class="ot">&lt;-</span> <span class="fu">check.restscore</span>(Communality)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in check.data(X): Varying numbers of item scores were observed across the items.
  Either the items have the same number of response categories but some item categories were not endorsed;
  or the items have
      different numbers of categories by design. 
  In the latter case, the sum score cannot be used for (ordinal) measurement.</code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(restscore.list)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>               ItemH #ac #vi #vi/#ac maxvi  sum sum/#ac zmax #zsig crit
reliable        0.30 432   7    0.02  0.09 0.31  0.0007 1.43     0   26
honest          0.27 432   5    0.01  0.07 0.25  0.0006 1.25     0   23
unscrupulous*   0.24 416   6    0.01  0.11 0.42  0.0010 1.46     0   33
deceitful*      0.32 400   8    0.02  0.09 0.40  0.0010 1.22     0   26
unintelligent*  0.12 416  14    0.03  0.11 0.86  0.0021 1.99     2   62
obnoxious*      0.29 432   7    0.02  0.11 0.52  0.0012 1.83     1   44
thankless*      0.25 432   7    0.02  0.08 0.38  0.0009 1.14     0   27
unfriendly*     0.31 432   8    0.02  0.11 0.48  0.0011 1.99     1   43
dependable      0.30 432   9    0.02  0.09 0.48  0.0011 1.22     0   28
cruel*          0.25 432   3    0.01  0.04 0.12  0.0003 0.67     0   16</code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(restscore.list)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-3.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-4.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-5.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-6.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-7.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-8.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-9.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-10.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-11.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-12.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-13.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-14.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-15.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-16.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-17.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-18.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-19.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-20.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-21.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-22.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-23.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-24.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-25.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-26.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-27.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-28.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-29.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-30.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-31.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-32.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-33.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-34.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-35.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-36.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-37.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-38.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-39.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-40.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-41.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-42.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-43.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-44.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="unit2_files/figure-html/unnamed-chunk-7-45.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Per interpretare i risultati ottenuti dal comando <code>summary(restscore.list)</code> è utile comprendere il significato delle varie colonne e come queste possono informare sulla qualità degli item in una scala di Mokken.</p>
<ol type="1">
<li><p><strong>ItemH</strong>: Questo è l’indice di H per ciascun item. L’indice di H misura la forza della relazione tra l’item e il punteggio totale della scala. Valori più alti indicano una migliore coerenza con la scala. Tipicamente, un valore di H superiore a 0.3 è considerato buono.</p></li>
<li><p><strong>#ac</strong>: Numero di soggetti che hanno risposto correttamente all’item (numero di osservazioni corrette).</p></li>
<li><p><strong>#vi</strong>: Numero di violazioni della monotonicità per l’item. La monotonicità implica che la probabilità di rispondere correttamente a un item non diminuisce con l’aumento del punteggio totale del soggetto. Un numero elevato di violazioni è indicativo di problemi con l’item.</p></li>
<li><p><strong>#vi/#ac</strong>: Proporzione di violazioni rispetto al numero di osservazioni corrette. Valori più bassi indicano migliori proprietà di monotonicità.</p></li>
<li><p><strong>maxvi</strong>: La massima violazione osservata della monotonicità per l’item. Valori più alti indicano maggiori problemi di monotonicità.</p></li>
<li><p><strong>sum</strong>: Somma delle violazioni. Fornisce un’indicazione del totale delle violazioni osservate per l’item.</p></li>
<li><p><strong>sum/#ac</strong>: Proporzione della somma delle violazioni rispetto al numero di osservazioni corrette.</p></li>
<li><p><strong>zmax</strong>: Z-scores per l’indice di violazione massimo. Fornisce un’indicazione della significatività statistica delle violazioni.</p></li>
<li><p><strong>#zsig</strong>: Numero di z-scores significativi. Indica quante delle violazioni sono statisticamente significative.</p></li>
<li><p><strong>crit</strong>: Un valore critico che combina vari indicatori per valutare la qualità dell’item. Valori più alti possono indicare problemi con l’item.</p></li>
</ol>
<p>Consideriamo alcuni esempi specifici dall’output ottenuto per chiarire meglio.</p>
<ol type="1">
<li><p><strong>reliable</strong></p>
<ul>
<li><strong>ItemH</strong>: 0.30 (buono)</li>
<li><strong>#ac</strong>: 432 (molti soggetti hanno risposto correttamente)</li>
<li><strong>#vi</strong>: 7 (pochi casi di violazioni)</li>
<li><strong>#vi/#ac</strong>: 0.02 (proporzione molto bassa)</li>
<li><strong>maxvi</strong>: 0.09 (violazione massima relativamente bassa)</li>
<li><strong>sum</strong>: 0.31 (totale violazioni basso)</li>
<li><strong>sum/#ac</strong>: 0.0007 (molto basso)</li>
<li><strong>zmax</strong>: 1.43 (nessuna violazione significativa, dato che <strong>#zsig</strong> è 0)</li>
<li><strong>crit</strong>: 26 (relativamente basso)</li>
</ul>
<p>L’item “reliable” sembra avere una buona coerenza con la scala, con pochi problemi di monotonicità.</p></li>
<li><p><strong>unintelligent</strong>*</p>
<ul>
<li><strong>ItemH</strong>: 0.12 (basso, indica che l’item non è molto coerente con la scala)</li>
<li><strong>#ac</strong>: 416</li>
<li><strong>#vi</strong>: 14 (numero relativamente alto di violazioni)</li>
<li><strong>#vi/#ac</strong>: 0.03 (proporzione più alta)</li>
<li><strong>maxvi</strong>: 0.11 (violazione massima più alta)</li>
<li><strong>sum</strong>: 0.86 (violazioni totali più alte)</li>
<li><strong>sum/#ac</strong>: 0.0021 (più alto rispetto ad altri item)</li>
<li><strong>zmax</strong>: 1.99 (significativo, dato che <strong>#zsig</strong> è 2)</li>
<li><strong>crit</strong>: 62 (più alto, indica problemi maggiori)</li>
</ul>
<p>L’item “unintelligent” presenta problemi significativi, con molte violazioni della monotonicità e un indice di H basso.</p></li>
</ol>
<p>In generale, per ogni item, valori più bassi di <strong>#vi</strong>, <strong>#vi/#ac</strong>, <strong>maxvi</strong>, <strong>sum</strong>, <strong>sum/#ac</strong>, <strong>zmax</strong>, <strong>#zsig</strong> e <strong>crit</strong> indicano un item con buone proprietà psicometriche. Valori alti di <strong>ItemH</strong> indicano una forte coerenza con la scala complessiva. Gli item contrassegnati con un asterisco (*) sembrano avere problemi maggiori e potrebbero necessitare di ulteriori indagini o potenzialmente essere rimossi dalla scala.</p>
</section>
<section id="proprietà-dellordine-di-mokken" class="level3">
<h3 class="anchored" data-anchor-id="proprietà-dellordine-di-mokken">Proprietà dell’ordine di Mokken</h3>
<p>La funzione <code>check.pmatrix()</code> è utilizzata per valutare la matrice delle probabilità (<code>pmatrix</code>) degli item in una scala di Mokken. Essa verifica se gli item soddisfano la condizione di scalabilità, nota anche come proprietà dell’ordine di Mokken. Questa proprietà implica che gli item devono mostrare un pattern coerente di risposta in modo che, se un soggetto risponde correttamente a un item difficile, dovrebbe rispondere correttamente anche a tutti gli item più facili.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>pmatrix.list <span class="ot">&lt;-</span> <span class="fu">check.pmatrix</span>(Communality)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in check.data(X): Varying numbers of item scores were observed across the items.
  Either the items have the same number of response categories but some item categories were not endorsed;
  or the items have
      different numbers of categories by design. 
  In the latter case, the sum score cannot be used for (ordinal) measurement.</code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(pmatrix.list)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>               ItemH  #ac #vi #vi/#ac maxvi  sum sum/#ac zmax #zsig crit
reliable        0.30 4608  22    0.00  0.05 0.85   2e-04 4.27    19   84
honest          0.27 4608   3    0.00  0.04 0.10   0e+00 2.75     3   41
unscrupulous*   0.24 4608   6    0.00  0.05 0.23   1e-04 4.06     6   60
deceitful*      0.32 4608   8    0.00  0.07 0.33   1e-04 3.06     7   56
unintelligent*  0.12 4608  12    0.00  0.08 0.50   1e-04 4.55    10   82
obnoxious*      0.29 4608   7    0.00  0.08 0.31   1e-04 5.12     7   69
thankless*      0.25 4608   7    0.00  0.08 0.33   1e-04 4.75     6   67
unfriendly*     0.31 4608   9    0.00  0.08 0.39   1e-04 4.45     8   67
dependable      0.30 4608  24    0.01  0.08 1.14   2e-04 5.12    23   98
cruel*          0.25 4608  10    0.00  0.06 0.37   1e-04 4.40     9   69</code></pre>
</div>
</div>
<p>L’output del comando <code>summary(pmatrix.list)</code> ottenuto dalla funzione <code>check.pmatrix()</code> del pacchetto <code>mokken</code> fornisce vari indicatori che aiutano a valutare la qualità degli item in una scala di Mokken.</p>
<ol type="1">
<li><strong>ItemH</strong>: Indice di scalabilità H per ciascun item. Valori più alti indicano una migliore coerenza con la scala. Tipicamente, un valore di H superiore a 0.3 è considerato buono.</li>
<li><strong>#ac</strong>: Numero di osservazioni considerate.</li>
<li><strong>#vi</strong>: Numero di violazioni della scalabilità per l’item. Una violazione si verifica quando la condizione di scalabilità non è rispettata.</li>
<li><strong>#vi/#ac</strong>: Proporzione di violazioni rispetto al numero di osservazioni considerate. Valori più bassi indicano migliori proprietà di scalabilità.</li>
<li><strong>maxvi</strong>: La massima violazione osservata della scalabilità per l’item. Valori più alti indicano maggiori problemi di scalabilità.</li>
<li><strong>sum</strong>: Somma delle violazioni. Fornisce un’indicazione del totale delle violazioni osservate per l’item.</li>
<li><strong>sum/#ac</strong>: Proporzione della somma delle violazioni rispetto al numero di osservazioni considerate.</li>
<li><strong>zmax</strong>: Z-scores per l’indice di violazione massimo. Fornisce un’indicazione della significatività statistica delle violazioni.</li>
<li><strong>#zsig</strong>: Numero di z-scores significativi. Indica quante delle violazioni sono statisticamente significative.</li>
<li><strong>crit</strong>: Un valore critico che combina vari indicatori per valutare la qualità dell’item. Valori più alti possono indicare problemi con l’item.</li>
</ol>
<p>Consideriamo i due item esaminati in precedenza.</p>
<ol type="1">
<li><p><strong>reliable</strong></p>
<ul>
<li><strong>ItemH</strong>: 0.30 (accettabile)</li>
<li><strong>#ac</strong>: 4608 (molti soggetti hanno risposto)</li>
<li><strong>#vi</strong>: 22 (numero di violazioni)</li>
<li><strong>#vi/#ac</strong>: 0.00 (proporzione molto bassa)</li>
<li><strong>maxvi</strong>: 0.05 (violazione massima relativamente bassa)</li>
<li><strong>sum</strong>: 0.85 (totale violazioni)</li>
<li><strong>sum/#ac</strong>: 2e-04 (molto basso)</li>
<li><strong>zmax</strong>: 4.27 (elevato, indica alcune violazioni significative)</li>
<li><strong>#zsig</strong>: 19 (violazioni statisticamente significative)</li>
<li><strong>crit</strong>: 84 (moderatamente alto)</li>
</ul>
<p>L’item “reliable” sembra essere coerente con la scala ma ha un numero moderato di violazioni significative.</p></li>
<li><p><strong>unintelligent</strong></p>
<ul>
<li><strong>ItemH</strong>: 0.12 (molto basso)</li>
<li><strong>#ac</strong>: 4608</li>
<li><strong>#vi</strong>: 12 (diverse violazioni)</li>
<li><strong>#vi/#ac</strong>: 0.00</li>
<li><strong>maxvi</strong>: 0.08</li>
<li><strong>sum</strong>: 0.50</li>
<li><strong>sum/#ac</strong>: 1e-04</li>
<li><strong>zmax</strong>: 4.55 (elevato)</li>
<li><strong>#zsig</strong>: 10</li>
<li><strong>crit</strong>: 82</li>
</ul>
<p>L’item “unintelligent” ha un indice di H molto basso e molte violazioni significative, indicando forti problemi di scalabilità.</p></li>
</ol>
<p>In sintesi, per interpretare questi risultati:</p>
<ul>
<li>Gli item con valori alti di <strong>ItemH</strong> (sopra 0.3) sono generalmente buoni, ma devono essere esaminati anche in termini di violazioni.</li>
<li>Gli item con molte violazioni (<strong>#vi</strong>), un alto valore di <strong>#vi/#ac</strong>, un alto <strong>maxvi</strong>, un alto <strong>zmax</strong>, e un alto <strong>#zsig</strong> indicano problemi di scalabilità e potrebbero necessitare di revisione o rimozione.</li>
<li>Gli item contrassegnati con un asterisco (*) presentano generalmente più problemi.</li>
</ul>
</section>
<section id="indipendenza-locale" class="level3">
<h3 class="anchored" data-anchor-id="indipendenza-locale">Indipendenza Locale</h3>
<p>La funzione <code>check.iio()</code> del pacchetto <code>mokken</code> è utilizzata per verificare la proprietà di indipendenza locale degli item (Item Independence Order, IIO) in una scala di Mokken. Questa proprietà implica che la probabilità di rispondere correttamente a un item non dovrebbe dipendere dalle risposte ad altri item, se si tiene conto della posizione del soggetto sulla scala latente.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>iio.list <span class="ot">&lt;-</span> <span class="fu">check.iio</span>(Communality)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in check.data(X): Varying numbers of item scores were observed across the items.
  Either the items have the same number of response categories but some item categories were not endorsed;
  or the items have
      different numbers of categories by design. 
  In the latter case, the sum score cannot be used for (ordinal) measurement.</code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(iio.list)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>$method
[1] "MIIO"

$item.summary
               ItemH #ac #vi #vi/#ac maxvi  sum sum/#ac tmax #tsig crit
cruel*          0.25  27   0    0.00  0.00 0.00  0.0000 0.00     0    0
unintelligent*  0.12  26   2    0.08  0.15 0.29  0.0112 2.16     1   74
unscrupulous*   0.24  26   1    0.04  0.14 0.14  0.0054 1.35     0   37
unfriendly*     0.31  27   1    0.04  0.15 0.15  0.0057 2.16     1   53
thankless*      0.24  27   1    0.04  0.12 0.12  0.0045 1.58     0   35
dependable      0.30  27   0    0.00  0.00 0.00  0.0000 0.00     0    0
obnoxious*      0.29  27   1    0.04  0.12 0.12  0.0045 1.58     0   33
reliable        0.30  27   0    0.00  0.00 0.00  0.0000 0.00     0    0
honest          0.26  27   2    0.07  0.18 0.31  0.0114 2.06     1   69
deceitful*      0.32  25   2    0.08  0.18 0.31  0.0124 2.06     1   69

$backward.selection
               step 1 step 2 step 3
cruel*              0      0      0
unintelligent*      1     NA     NA
unscrupulous*       0      0      0
unfriendly*         1      0      0
thankless*          0      0      0
dependable          0      0      0
obnoxious*          0      0      0
reliable            0      0      0
honest              1      1     NA
deceitful*          1      1      0

$HT
[1] 0.07338353</code></pre>
</div>
</div>
<p>L’output della funzione <code>check.iio()</code> fornisce informazioni riguardanti la coerenza e la qualità degli item rispetto alla proprietà di indipendenza locale.</p>
<ol type="1">
<li><strong>ItemH</strong>: Indice di scalabilità H per ciascun item. Valori più alti indicano una migliore coerenza con la scala.</li>
<li><strong>#ac</strong>: Numero di casi esaminati per ciascun item.</li>
<li><strong>#vi</strong>: Numero di violazioni della proprietà IIO per l’item.</li>
<li><strong>#vi/#ac</strong>: Proporzione di violazioni rispetto al numero di casi esaminati. Valori più bassi indicano migliori proprietà di indipendenza locale.</li>
<li><strong>maxvi</strong>: La massima violazione osservata della proprietà IIO per l’item. Valori più alti indicano maggiori problemi.</li>
<li><strong>sum</strong>: Somma delle violazioni della proprietà IIO.</li>
<li><strong>sum/#ac</strong>: Proporzione della somma delle violazioni rispetto al numero di casi esaminati.</li>
<li><strong>tmax</strong>: Valore massimo della statistica T per le violazioni dell’IIO.</li>
<li><strong>#tsig</strong>: Numero di valori T significativi. Indica quante delle violazioni sono statisticamente significative.</li>
<li><strong>crit</strong>: Un valore critico che combina vari indicatori per valutare la qualità dell’item. Valori più alti possono indicare problemi con l’item.</li>
</ol>
<p>Esempio di interpretazione degli item.</p>
<ul>
<li><strong>unintelligent</strong>
<ul>
<li><strong>ItemH</strong>: 0.12 (basso, indica che l’item non è molto coerente con la scala).</li>
<li><strong>#ac</strong>: 26</li>
<li><strong>#vi</strong>: 2 (alcune violazioni).</li>
<li><strong>#vi/#ac</strong>: 0.08 (proporzione moderata di violazioni).</li>
<li><strong>maxvi</strong>: 0.15 (violazione massima moderata).</li>
<li><strong>sum</strong>: 0.29 (violazioni totali moderate).</li>
<li><strong>sum/#ac</strong>: 0.0112 (proporzione di violazioni relativamente alta).</li>
<li><strong>tmax</strong>: 2.16 (violazione significativa).</li>
<li><strong>#tsig</strong>: 1 (una violazione significativa).</li>
<li><strong>crit</strong>: 74 (alto, indica problemi significativi).</li>
</ul></li>
</ul>
<p>L’item “unintelligent” presenta problemi significativi di indipendenza locale.</p>
<ul>
<li><strong>dependable</strong>
<ul>
<li><strong>ItemH</strong>: 0.30 (buono).</li>
<li><strong>#ac</strong>: 27</li>
<li><strong>#vi</strong>: 0 (nessuna violazione).</li>
<li><strong>#vi/#ac</strong>: 0.00</li>
<li><strong>maxvi</strong>: 0.00</li>
<li><strong>sum</strong>: 0.00</li>
<li><strong>sum/#ac</strong>: 0.0000</li>
<li><strong>tmax</strong>: 0.00</li>
<li><strong>#tsig</strong>: 0</li>
<li><strong>crit</strong>: 0</li>
</ul></li>
</ul>
<p>L’item “dependable” non presenta violazioni della proprietà di indipendenza locale ed è altamente coerente con la scala.</p>
<p>La sezione <code>backward.selection</code> mostra il risultato della selezione all’indietro per identificare gli item problematici. Ogni colonna rappresenta un passaggio del processo di selezione:</p>
<ul>
<li><strong>0</strong>: L’item è mantenuto.</li>
<li><strong>1</strong>: L’item è stato rimosso a questo passaggio.</li>
</ul>
<p>Esempio di interpretazione:</p>
<ul>
<li><strong>unintelligent</strong>: Rimosso al passo 1.</li>
<li><strong>honest</strong>: Rimosso al passo 1 e mantenuto al passo 2.</li>
<li><strong>deceitful</strong>: Rimosso al passo 1 e mantenuto al passo 2.</li>
</ul>
<p>Infine, l’indice HT è una misura della forza della struttura di scala di Mokken. Un valore più alto indica una struttura più forte. In questo caso, un valore di 0.07338353 è relativamente basso, indicando che la struttura della scala potrebbe non essere molto forte.</p>
<p>In conclusione, la funzione <code>check.iio()</code> aiuta a identificare gli item che non soddisfano la proprietà di indipendenza locale in una scala di Mokken. Gli item con molte violazioni e un alto valore di crit sono problematici e potrebbero dover essere rivisti o rimossi. Il processo di selezione all’indietro aiuta a identificare questi item e a migliorare la qualità complessiva della scala.</p>
</section>
<section id="affidabilità" class="level3">
<h3 class="anchored" data-anchor-id="affidabilità">Affidabilità</h3>
<p>La funzione <code>check.reliability()</code> del pacchetto <code>mokken</code> è utilizzata per valutare l’affidabilità di una scala psicometrica. L’affidabilità è una misura della coerenza interna degli item di una scala e indica quanto gli item misurano coerentemente lo stesso costrutto.</p>
<p>Questa funzione calcola diversi indici di affidabilità, inclusi il coefficiente di scalabilità di Mokken, l’alpha di Cronbach e il lambda-2 di Guttman.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="fu">check.reliability</span>(Communality)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in check.data(X): Varying numbers of item scores were observed across the items.
  Either the items have the same number of response categories but some item categories were not endorsed;
  or the items have
      different numbers of categories by design. 
  In the latter case, the sum score cannot be used for (ordinal) measurement.</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>$MS
[1] 0.7585348

$alpha
[1] 0.7465871

$lambda.2
[1] 0.7568063</code></pre>
</div>
</div>
<ul>
<li>Il coefficiente di scalabilità di Mokken (MS) misura la forza della struttura di scala non parametrica degli item. Un valore più alto indica una scala più forte e coerente. Valori sopra 0.3 sono considerati accettabili, mentre valori sopra 0.5 indicano una buona scalabilità. Un valore di 0.7585348 suggerisce una scala molto forte e ben strutturata.</li>
<li>L’alpha di Cronbach è una misura comune della coerenza interna di una scala. Essa valuta quanto bene gli item della scala misurano lo stesso costrutto. Valori di alpha sopra 0.7 sono considerati accettabili, mentre valori sopra 0.8 sono considerati buoni. Un valore di 0.7465871 indica una buona coerenza interna della scala, sebbene sia leggermente inferiore alla soglia di eccellenza di 0.8.</li>
<li>Il lambda-2 di Guttman è un altro indice di affidabilità che può essere più robusto dell’alpha di Cronbach in alcune circostanze. Valori più alti indicano maggiore affidabilità. Un valore di 0.7568063 è simile all’alpha di Cronbach e suggerisce una buona affidabilità.</li>
</ul>
<p>Nel complesso, i risultati indicano che la scala può essere considerata affidabile per la misurazione del costrutto in esame. Tuttavia, potrebbe esserci spazio per migliorare leggermente l’alpha di Cronbach per ottenere una coerenza interna ancora migliore.</p>
</section>
<section id="automated-item-selection-procedure" class="level3">
<h3 class="anchored" data-anchor-id="automated-item-selection-procedure">Automated Item Selection Procedure</h3>
<p>La funzione <code>aisp()</code> del pacchetto <code>mokken</code> in R viene utilizzata per identificare i pattern di item (Item Scalability Patterns) che soddisfano specifici criteri di scalabilità all’interno di una scala. Essa aiuta a determinare quali item contribuiscono alla struttura scalare della scala di Mokken.</p>
<p><code>aisp()</code> sta per “Automated Item Selection Procedure” ed è una procedura automatizzata per la selezione degli item che meglio soddisfano i criteri di scalabilità definiti dall’utente.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">aisp</span>(Communality, <span class="at">lowerbound =</span> <span class="fl">0.3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in check.data(X): Varying numbers of item scores were observed across the items.
  Either the items have the same number of response categories but some item categories were not endorsed;
  or the items have
      different numbers of categories by design. 
  In the latter case, the sum score cannot be used for (ordinal) measurement.</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>               0.3
reliable         1
honest           1
unscrupulous*    0
deceitful*       1
unintelligent*   0
obnoxious*       2
thankless*       2
unfriendly*      2
dependable       1
cruel*           2</code></pre>
</div>
</div>
<p>L’output di <code>aisp()</code> mostra i pattern di scalabilità degli item. Gli item sono valutati in base alla loro capacità di soddisfare il criterio di scalabilità.</p>
<ul>
<li><strong>0.3</strong>: Questo rappresenta la soglia di scalabilità (H) utilizzata nella selezione degli item.</li>
<li><strong>Valori associati agli item</strong>:
<ul>
<li><strong>1</strong>: L’item soddisfa il criterio di scalabilità con un coefficiente H superiore a 0.3.</li>
<li><strong>0</strong>: L’item non soddisfa il criterio di scalabilità con un coefficiente H inferiore a 0.3.</li>
<li><strong>2</strong>: L’item è considerato problematico, probabilmente per la presenza di molteplici violazioni della monotonicità o altre problematiche di scalabilità.</li>
</ul></li>
</ul>
<p>Dettaglio degli item</p>
<ol type="1">
<li><strong>reliable</strong>: 1
<ul>
<li>Questo item soddisfa il criterio di scalabilità e ha un coefficiente H superiore a 0.3.</li>
</ul></li>
<li><strong>honest</strong>: 1
<ul>
<li>Anche questo item soddisfa il criterio di scalabilità con un coefficiente H superiore a 0.3.</li>
</ul></li>
<li><strong>unscrupulous</strong>: 0
<ul>
<li>Questo item non soddisfa il criterio di scalabilità, avendo un coefficiente H inferiore a 0.3.</li>
</ul></li>
<li><strong>deceitful</strong>: 1
<ul>
<li>Questo item soddisfa il criterio di scalabilità con un coefficiente H superiore a 0.3.</li>
</ul></li>
<li><strong>unintelligent</strong>: 0
<ul>
<li>Questo item non soddisfa il criterio di scalabilità, avendo un coefficiente H inferiore a 0.3.</li>
</ul></li>
<li><strong>obnoxious</strong>: 2
<ul>
<li>Questo item è problematico e non soddisfa completamente il criterio di scalabilità, probabilmente a causa di violazioni della monotonicità.</li>
</ul></li>
<li><strong>thankless</strong>: 2
<ul>
<li>Anche questo item è problematico e non soddisfa completamente il criterio di scalabilità, con possibili violazioni della monotonicità.</li>
</ul></li>
<li><strong>unfriendly</strong>: 2
<ul>
<li>Questo item è problematico e presenta molteplici violazioni della monotonicità, quindi non soddisfa il criterio di scalabilità.</li>
</ul></li>
<li><strong>dependable</strong>: 1
<ul>
<li>Questo item soddisfa il criterio di scalabilità con un coefficiente H superiore a 0.3.</li>
</ul></li>
<li><strong>cruel</strong>: 2
<ul>
<li>Questo item è problematico e non soddisfa completamente il criterio di scalabilità, con possibili violazioni della monotonicità.</li>
</ul></li>
</ol>
<p>L’output della funzione <code>aisp()</code> aiuta a identificare quali item in una scala di Mokken soddisfano i criteri di scalabilità e quali no. Gli item con valore <strong>1</strong> sono quelli che soddisfano il criterio di scalabilità (H &gt; 0.3), mentre quelli con valore <strong>0</strong> non lo soddisfano. Gli item con valore <strong>2</strong> sono considerati problematici e potrebbero necessitare di revisione o rimozione dalla scala. Utilizzare queste informazioni per migliorare la qualità complessiva della scala, garantendo che solo gli item con buone proprietà di scalabilità siano inclusi.</p>


<!-- -->

</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/ccaudek\.github\.io\/lab-test-psi-quarto\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb36" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Scale di Mokken"</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="co">  html:</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="co">    code-fold: show</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="co">    code-tools: true</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a><span class="fu">suppressPackageStartupMessages</span>({</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">library</span>(mokken)</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>L'Analisi delle Scale Mokken (MSA), così denominata in onore del matematico e scienziato politico olandese Robert J. Mokken, è un insieme di metodi utilizzati nell'ambito della Teoria Non Parametrica della Risposta agli Item (NIRT) per valutare l'adeguatezza dei dati ai suoi modelli. </span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>Secondo la Teoria della Risposta agli Item (IRT), i costrutti psicologici sono  latenti, ovvero non direttamente osservabili, e si manifestano attraverso le risposte ai test. Le reazioni dei partecipanti ai test (cioè, le risposte agli item) dipendono dalla posizione del rispondente su un continuum latente e riflettono il grado in cui i rispondenti possiedono il costrutto in esame.</span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>È chiaro però che la relazione tra la posizione del rispondente su un continuum latente e le sue risposte agli item, a causa degli errori di misurazione, non è una relazione diretta. Il contributo dei modelli della NIRT è quelllo di fornire gli strumenti analitici necessari per esaminare la congruenza e la pertinenza degli item di un test con la variabile latente sottostante. In particolare, i modelli MSA, che sono modelli probabilistici basati su tratti latenti e, avendo una natura non parametrica, sono caratterizzati da presupposti meno restrittivi rispetto ai modelli IRT parametrici, possono essere usati nella validazione di strumenti di misura psicometrici e nell'ordinare rispondenti e item lungo una scala ordinale. I modelli MSA sono applicabili sia a item dicotomici che politomici.</span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a><span class="fu">## Teoria Classica dei Test e Analisi della Scala di Mokken </span></span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>Esaminiamo ora le somiglianze e le differenze tra la Teoria Classica dei Test (CTT) e l'Analisi della Scala di Mokken (MSA).</span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a>La CTT si basa su diverse assunzioni fondamentali:</span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>I punteggi osservati sono la somma dei punteggi veri e dei punteggi di errore, con l'aspettativa che i punteggi di errore abbiano una media di zero su prove ripetute.</span>
<span id="cb36-30"><a href="#cb36-30" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Non c'è correlazione tra i punteggi di errore e i punteggi veri.</span>
<span id="cb36-31"><a href="#cb36-31" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>I punteggi veri in un test non sono correlati ai punteggi di errore in un altro test.</span>
<span id="cb36-32"><a href="#cb36-32" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>I punteggi di errore in due test somministrati agli stessi soggetti sono non correlati.</span>
<span id="cb36-33"><a href="#cb36-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-34"><a href="#cb36-34" aria-hidden="true" tabindex="-1"></a>Nella CTT, i punteggi grezzi totali sono considerati indicatori delle posizioni dei rispondenti sul continuum del tratto latente. La proporzione di item corretti (valore p) indica la facilità degli item, mentre la correlazione tra item e punteggio totale misura la discriminazione degli item. La CTT enfatizza l'importanza dell'affidabilità, definita come la correlazione tra i punteggi osservati su due forme parallele del test.</span>
<span id="cb36-35"><a href="#cb36-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-36"><a href="#cb36-36" aria-hidden="true" tabindex="-1"></a>Confrontando la CTT con la MSA, troviamo alcune somiglianze nelle metodologie di calcolo degli indici di abilità delle persone e di difficoltà degli item. Nella MSA,</span>
<span id="cb36-37"><a href="#cb36-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-38"><a href="#cb36-38" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>il *coefficiente di scalabilità dell'item (Hi)* è analogo alle correlazioni corrette tra item e punteggio totale nella CTT;</span>
<span id="cb36-39"><a href="#cb36-39" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>il *coefficiente di scalabilità tra coppie di item (Hij)* nella MSA corrisponde alle correlazioni tra coppie di item nella CTT;</span>
<span id="cb36-40"><a href="#cb36-40" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>il *coefficiente di scalabilità complessivo (H)* nella MSA è paragonabile agli indici di discriminazione media degli item nella CTT.</span>
<span id="cb36-41"><a href="#cb36-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-42"><a href="#cb36-42" aria-hidden="true" tabindex="-1"></a>Tuttavia, una differenza fondamentale tra la MSA e la CTT risiede nella testabilità dei modelli. A differenza della CTT, i modelli MSA permettono di verificare empiricamente le loro assunzioni, come l'indipendenza locale, l'unidimensionalità e la monotonicità. Ad esempio, un coefficiente di scalabilità negativo nella MSA smentirebbe gli assiomi del Modello di Omogeneità Monotona (MHM). Questa capacità di testare empiricamente le sue assunzioni rende la MSA un modello particolarmente robusto e trasparente.</span>
<span id="cb36-43"><a href="#cb36-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-44"><a href="#cb36-44" aria-hidden="true" tabindex="-1"></a>In conclusione, mentre la CTT fornisce un quadro teorico solido per la comprensione e l'interpretazione dei punteggi dei test, ma non fornisce direttamente gli strumenti statistici per testare le assunzioni del modello, la MSA offre un approccio  testabile e più flessibile. La MSA di dimostra dunque particolarmente utile nell'analizzare la struttura dei dati dei test e nella valutazione della validità delle scale di misurazione. Queste caratteristiche rendono la MSA un complemento prezioso alla CTT nella pratica della misurazione psicologica.</span>
<span id="cb36-45"><a href="#cb36-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-46"><a href="#cb36-46" aria-hidden="true" tabindex="-1"></a><span class="fu">## Analisi delle Scale di Mokken e Item Politomici</span></span>
<span id="cb36-47"><a href="#cb36-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-48"><a href="#cb36-48" aria-hidden="true" tabindex="-1"></a>La MSA è stata inizialmente sviluppata per item dicotomici. In seguito però è stata estesa da Molenaar (1982a, 1997) per includere anche gli item politomici. Questa estensione mantiene i principi fondamentali della MSA applicati agli item dicotomici, ma aggiunge alcune specificità legate alla natura degli item politomici.</span>
<span id="cb36-49"><a href="#cb36-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-50"><a href="#cb36-50" aria-hidden="true" tabindex="-1"></a>Nel caso degli item politomici, come quelli usati nelle scale Likert, le assunzioni del modello MSA vengono esaminate non solo a livello dell'intero item, ma anche per ciascun "passaggio" o categoria di risposta. Prendendo come esempio un item Likert a cinque punti, che va da "fortemente d'accordo" a "fortemente in disaccordo", ci sono quattro passaggi distinti, ognuno rappresentante una transizione tra due categorie consecutive.</span>
<span id="cb36-51"><a href="#cb36-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-52"><a href="#cb36-52" aria-hidden="true" tabindex="-1"></a>Per ogni passaggio di un item politomico, si definisce una Funzione di Risposta del Passaggio dell'Item (ISRF), che descrive la probabilità di scegliere una specifica categoria di risposta in funzione del tratto latente θ. Le ISRF sono cruciali per comprendere come le diverse categorie di risposta si relazionino al tratto latente misurato dall'item.</span>
<span id="cb36-53"><a href="#cb36-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-54"><a href="#cb36-54" aria-hidden="true" tabindex="-1"></a>Affinché il modello di omogeneità monotona sia valido per gli item politomici, è necessario che le probabilità di scegliere una categoria di risposta k o superiore aumentino monotonamente con l'aumento di θ. Questo implica che le categorie di risposta debbano essere ordinate in modo significativo, rappresentando livelli progressivamente più alti del tratto latente.</span>
<span id="cb36-55"><a href="#cb36-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-56"><a href="#cb36-56" aria-hidden="true" tabindex="-1"></a>Un aspetto fondamentale nell'analisi di item politomici nella MSA è l'assunzione di monotonicità, che richiede che le ISRF siano funzioni crescenti in θ. In altre parole, man mano che il tratto latente aumenta, aumenta anche la probabilità che un individuo scelga categorie di risposta superiori.</span>
<span id="cb36-57"><a href="#cb36-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-58"><a href="#cb36-58" aria-hidden="true" tabindex="-1"></a>In sintesi, l'estensione della MSA agli item politomici fornisce uno strumento potente per analizzare item con più categorie di risposta, consentendo una misurazione più dettagliata e sfumata del tratto latente. Questa estensione rende la MSA particolarmente adatta per applicazioni in cui si utilizzano scale di risposta con gradazioni multiple, come nei questionari di valutazione del benessere psicologico, nei sondaggi di opinione o nelle valutazioni educative. Attraverso l'analisi dei passaggi degli item, la MSA per item politomici permette una comprensione più approfondita di come gli individui interagiscano con le diverse opzioni di risposta e di come queste risposte riflettano i loro livelli sul tratto latente. </span>
<span id="cb36-59"><a href="#cb36-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-60"><a href="#cb36-60" aria-hidden="true" tabindex="-1"></a><span class="fu">## L'Affidabilità nei Test</span></span>
<span id="cb36-61"><a href="#cb36-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-62"><a href="#cb36-62" aria-hidden="true" tabindex="-1"></a>L'affidabilità in ambito di test psicometrici si riferisce al grado in cui un test è esente da errori di misurazione. Si valuta tipicamente esaminando la stabilità dei punteggi ottenuti dagli esaminandi in diverse somministrazioni del test, sia nel tempo che attraverso forme parallele del test. L'idea di base è che, in assenza di cambiamenti nei punteggi veri degli esaminandi, ci si aspetterebbe una correlazione perfetta tra le diverse amministrazioni. Ogni deviazione da questa correlazione perfetta è attribuita all'influenza dell'errore di misurazione.</span>
<span id="cb36-63"><a href="#cb36-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-64"><a href="#cb36-64" aria-hidden="true" tabindex="-1"></a>Tuttavia, ottenere misure di affidabilità attraverso forme parallele o ripetute somministrazioni nel tempo può essere impraticabile, a causa di problemi logistici e degli effetti di memoria o pratica. Pertanto, l'affidabilità è spesso stimata attraverso metodi che richiedono una singola somministrazione del test.</span>
<span id="cb36-65"><a href="#cb36-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-66"><a href="#cb36-66" aria-hidden="true" tabindex="-1"></a>L'alfa di Cronbach è uno degli estimatori di affidabilità più utilizzati, sebbene presenti diverse limitazioni. In risposta a queste limitazioni, Mokken (1971) ha sviluppato un coefficiente di affidabilità non distorto, noto come ρ (rho) o statistica MS. Questo coefficiente presuppone la validità della doppia monotonicità, una supposizione piuttosto forte. Per affrontare alcune delle sfide associate alla statistica ρ, Van der Ark, Van der Palm e Sijtsma (2011) hanno proposto un altro indicatore di affidabilità chiamato Coefficiente di Affidabilità delle Classi Latenti (LCRC). Questo è uno stimatore non distorto dell'affidabilità dei punteggi dei test, le cui assunzioni sono meno stringenti rispetto alla statistica ρ, richiedendo solamente l'indipendenza locale. Questo rappresenta un vantaggio significativo del coefficiente LCRC rispetto al coefficiente ρ, poiché rende l'LCRC più applicabile e flessibile in una varietà di contesti di test.</span>
<span id="cb36-67"><a href="#cb36-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-68"><a href="#cb36-68" aria-hidden="true" tabindex="-1"></a>In conclusione, la scelta del metodo più appropriato per stimare l'affidabilità dipende dalle caratteristiche specifiche del test e dalle esigenze di misurazione. Mentre l'alfa di Cronbach rimane uno standard ampiamente utilizzato, le alternative come il coefficiente ρ di Mokken e il LCRC offrono strumenti aggiuntivi e talvolta più adatti per valutare l'affidabilità, specialmente in situazioni dove le assunzioni dell'alfa di Cronbach non sono soddisfatte o quando si utilizzano modelli non parametrici come quelli proposti nell'Analisi delle Scale di Mokken.</span>
<span id="cb36-69"><a href="#cb36-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-70"><a href="#cb36-70" aria-hidden="true" tabindex="-1"></a><span class="fu">## Coefficienti di Scalabilità nelle Scale Mokken</span></span>
<span id="cb36-71"><a href="#cb36-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-72"><a href="#cb36-72" aria-hidden="true" tabindex="-1"></a>I coefficienti di scalabilità nelle Scale Mokken, ovvero $H$, $H_i$ e $H_{ij}$, sono indici chiave utilizzati per valutare la qualità di una misurazione nell'Analisi delle Scale Mokken (MSA). Questi coefficienti misurano la coerenza e l'ordinamento degli item e dei punteggi complessivi su un continuum latente, indicando in che misura gli item formano una gerarchia e se i punteggi degli item sono ordinati consistentemente.</span>
<span id="cb36-73"><a href="#cb36-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-74"><a href="#cb36-74" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Coefficienti di Scalabilità Singoli ($H_i$)**: Indicano la qualità di ogni singolo item. Un valore elevato di $H_i$ significa che l'item ha una buona discriminazione e contribuisce efficacemente all'ordinamento degli esaminandi. Valori superiori a 0.30 sono generalmente considerati accettabili.</span>
<span id="cb36-75"><a href="#cb36-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-76"><a href="#cb36-76" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Coefficienti di Scalabilità per Coppie di Item ($H_{ij}$)**: Misurano la coerenza tra coppie di item. Valori positivi indicano che la coppia di item è coerente con il modello di omogeneità monotona. Valori negativi possono suggerire multidimensionalità o non monotonicità.</span>
<span id="cb36-77"><a href="#cb36-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-78"><a href="#cb36-78" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Coefficienti di Scalabilità per l'Intero Test ($H$)**: Questo indice valuta la qualità dell'intero test, indicando in che misura la struttura complessiva dei dati si avvicina a un modello di Guttman perfetto. Valori tra 0.30 e 0.40 indicano una scala debole, tra 0.40 e 0.50 una scala media e superiori a 0.50 una scala forte.</span>
<span id="cb36-79"><a href="#cb36-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-80"><a href="#cb36-80" aria-hidden="true" tabindex="-1"></a>Questi coefficienti vengono calcolati basandosi sul rapporto tra gli errori di Guttman osservati e quelli attesi. Un coefficiente di $H$ vicino a uno implica una perfetta conformità al modello di Guttman, mentre valori vicini a zero indicano la presenza di numerosi errori di Guttman.</span>
<span id="cb36-81"><a href="#cb36-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-82"><a href="#cb36-82" aria-hidden="true" tabindex="-1"></a>La MSA consente di testare empiricamente se i dati si adattano al modello di omogeneità monotona, fornendo un quadro robusto per l'analisi degli item e dei punteggi dei test. I coefficienti di scalabilità offrono una guida per determinare la qualità e la coerenza degli item nel contesto di una scala unidimensionale. Sono particolarmente utili per identificare item che potrebbero essere ridondanti o non allineati con il tratto latente misurato.</span>
<span id="cb36-83"><a href="#cb36-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-84"><a href="#cb36-84" aria-hidden="true" tabindex="-1"></a>Inoltre, i coefficienti di scalabilità forniscono informazioni preziose sulla validità di costrutto di una scala. Anche se una scala ha una forte discriminazione (indicata da valori elevati di $H_i$ e $H$), potrebbe mancare di validità di costrutto se i suoi item misurano solo una porzione ristretta del costrutto. Allo stesso modo, valori elevati di $H_{ij}$ tra specifiche coppie di item possono suggerire che uno degli item nella coppia sia ridondante.</span>
<span id="cb36-85"><a href="#cb36-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-86"><a href="#cb36-86" aria-hidden="true" tabindex="-1"></a>In sintesi, i coefficienti di scalabilità nelle Scale Mokken non solo valutano la precisione nell'ordinamento degli esaminandi e la qualità degli item, ma aiutano anche a comprendere meglio la struttura e la validità di una scala. Questi coefficienti, quindi, giocano un ruolo cruciale nella selezione e nell'analisi degli item in contesti di misurazione psicometrica, educativa e di ricerca.</span>
<span id="cb36-87"><a href="#cb36-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-88"><a href="#cb36-88" aria-hidden="true" tabindex="-1"></a><span class="fu">## Gli Errori Standard nei Coefficienti di Scalabilità delle Scale Mokken</span></span>
<span id="cb36-89"><a href="#cb36-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-90"><a href="#cb36-90" aria-hidden="true" tabindex="-1"></a>Gli errori standard (SE) sono fondamentali per interpretare correttamente i coefficienti di scalabilità nelle scale Mokken. Questi errori standard tengono conto dell'incertezza delle stime. Se l'errore standard è grande rispetto al coefficiente stesso, ad esempio un SE di .08 per un coefficiente Hi di .30, è probabile che il valore reale del coefficiente nella popolazione sia inferiore a .30, suggerendo che gli item potrebbero non essere scalabili. </span>
<span id="cb36-91"><a href="#cb36-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-92"><a href="#cb36-92" aria-hidden="true" tabindex="-1"></a>La dimensione dell'errore standard dipende da due fattori: la dimensione del campione e l'asimmetria delle distribuzioni dei punteggi degli item. Con un campione più grande, gli errori standard sono generalmente più piccoli, mentre distribuzioni dei punteggi più asimmetriche portano a errori standard più grandi. Tuttavia, un ampio campione non garantisce stime precise dei coefficienti di scalabilità.</span>
<span id="cb36-93"><a href="#cb36-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-94"><a href="#cb36-94" aria-hidden="true" tabindex="-1"></a>Per i coefficienti di scalabilità, possiamo calcolare gli intervalli di confidenza al 95% (CI) usando la formula:</span>
<span id="cb36-95"><a href="#cb36-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-96"><a href="#cb36-96" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb36-97"><a href="#cb36-97" aria-hidden="true" tabindex="-1"></a>\text{95% CI} = H_i \pm (1.96 \times \text{SE}) </span>
<span id="cb36-98"><a href="#cb36-98" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb36-99"><a href="#cb36-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-100"><a href="#cb36-100" aria-hidden="true" tabindex="-1"></a>Per esempio, se $H_i$ è .30 con un SE di .10, il CI sarà tra .10 e .50. Questo intervallo ampio implica che il valore reale di $H_i$, con il 95% di confidenza, si trova in questo range, indicando una bassa affidabilità del coefficiente. Se $H_i$ è .15 con un SE di .10, il CI sarà tra -.05 e .35, suggerendo che il vero coefficiente potrebbe essere zero o anche negativo nella popolazione, e quindi l'item dovrebbe essere scartato.</span>
<span id="cb36-101"><a href="#cb36-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-102"><a href="#cb36-102" aria-hidden="true" tabindex="-1"></a>Mokken (1971) ha indicato che la monotonicità delle funzioni di risposta all'item (IRF) per tutti gli item utilizzati nel calcolo del punteggio totale X+ è una condizione sufficiente per la loro utilità nella classificazione degli esaminandi. Di conseguenza, gli item con bassi coefficienti di scalabilità vengono generalmente scartati. </span>
<span id="cb36-103"><a href="#cb36-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-104"><a href="#cb36-104" aria-hidden="true" tabindex="-1"></a>Tuttavia, Crișan e colleghi (2020) consigliano di non rimuovere item inadatti dalle scale se non vi sono altri argomenti (ad esempio, di contenuto) per farlo. I guadagni in affidabilità, selezione delle persone e validità predittiva potrebbero non compensare la perdita di copertura del costrutto e validità dei criteri. Pertanto, la decisione di mantenere o rimuovere item da una scala dovrebbe basarsi principalmente su considerazioni teoriche, e i ricercatori applicati dovrebbero essere cauti nel non utilizzare regole empiriche per eliminare item in modo acritico.</span>
<span id="cb36-105"><a href="#cb36-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-106"><a href="#cb36-106" aria-hidden="true" tabindex="-1"></a>In sintesi, l'analisi degli errori standard nei coefficienti di scalabilità delle scale Mokken fornisce informazioni cruciali sulla affidabilità e la validità degli item della scala. Tuttavia, le decisioni su quali item mantenere o scartare dovrebbero essere prese considerando non solo gli aspetti psicometrici ma anche il contesto teorico e il contenuto della scala stessa.</span>
<span id="cb36-107"><a href="#cb36-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-108"><a href="#cb36-108" aria-hidden="true" tabindex="-1"></a><span class="fu">## Procedura di Selezione Automatica degli Item </span></span>
<span id="cb36-109"><a href="#cb36-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-110"><a href="#cb36-110" aria-hidden="true" tabindex="-1"></a>La Procedura di Selezione Automatica degli Item (AISP) è una metodologia impiegata nella MSA per selezionare un insieme di item da un pool più ampio che aderiscano alle assunzioni del Modello di Mokken (MHM). L'AISP aiuta a esaminare l'unidimensionalità e identifica item non scalabili.</span>
<span id="cb36-111"><a href="#cb36-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-112"><a href="#cb36-112" aria-hidden="true" tabindex="-1"></a>Una scala di Mokken si compone di una serie di item selezionati in base a due criteri specifici. Prima di tutto, ogni item deve avere una covarianza ($H_{i}$) che superi un valore soglia (c), scelto dall'utente. Solitamente, si raccomanda di impostare questo valore soglia a c=.30. Il secondo criterio richiede che la covarianza tra ogni coppia di item ($H_{ij}$) sia maggiore di zero. In sintesi, per essere inclusi in una scala di Mokken, gli item devono avere sia una covarianza individuale ($H_{i}$) sia una covarianza reciproca ($H_{ij}$) positive e superiori a un valore minimo predefinito.</span>
<span id="cb36-113"><a href="#cb36-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-114"><a href="#cb36-114" aria-hidden="true" tabindex="-1"></a>Questo processo inizia selezionando due item con la più alta $H_{ij}$ e continua aggiungendo nuovi item che soddisfano i criteri. Se alcuni item non rispettano questi criteri, l'AISP tenta di costruire una seconda scala o li identifica come non scalabili.</span>
<span id="cb36-115"><a href="#cb36-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-116"><a href="#cb36-116" aria-hidden="true" tabindex="-1"></a>Le scale costruite con l'AISP misurano un tratto latente comune, ordina in modo affidabile le persone e discriminano bene. Tuttavia, talvolta, un item può essere selezionato con un valore $H_{i}$ inferiore a c, contraddicendo la definizione di scala di Mokken. Questi item inadatti dovrebbero essere esclusi successivamente.</span>
<span id="cb36-117"><a href="#cb36-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-118"><a href="#cb36-118" aria-hidden="true" tabindex="-1"></a>L'AISP può essere vista come un'alternativa più efficiente all'analisi fattoriale, in quanto non è influenzata dalle difficoltà degli item e può essere applicata sia a item dicotomici che politomici. Tuttavia, i ricercatori dovrebbero considerare la teoria sostanziale e non affidarsi solo alle soluzioni statistiche prodotte dal software.</span>
<span id="cb36-119"><a href="#cb36-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-120"><a href="#cb36-120" aria-hidden="true" tabindex="-1"></a>È importante notare che la scelta del valore limite inferiore c influisce sulla struttura della scala identificata. Valori più alti di c possono portare al rifiuto di molti item e alla formazione di scale sostanzialmente prive di significato con pochi item. D'altra parte, valori bassi di c possono nascondere la vera dimensionalità dei dati includendo tutti gli item in una singola scala. Il valore scelto dovrebbe dipendere dall'obiettivo specifico della ricerca.</span>
<span id="cb36-121"><a href="#cb36-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-122"><a href="#cb36-122" aria-hidden="true" tabindex="-1"></a>Inoltre, l'AISP è paragonabile all'analisi fattoriale esplorativa, ma a differenza dell'analisi fattoriale, l'AISP può concludere senza trovare una scala valida se tutti i valori di $H_{ij}$ sono inferiori a .30. Invece, l'analisi fattoriale trova sempre una soluzione, anche se non necessariamente significativa.</span>
<span id="cb36-123"><a href="#cb36-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-124"><a href="#cb36-124" aria-hidden="true" tabindex="-1"></a>In conclusione, l'AISP è uno strumento utile per la costruzione di scale di Mokken, ma presenta limitazioni nella valutazione della dimensionalità. Gli studi di simulazione mostrano che questo metodo può essere meno efficiente rispetto ad altri metodi non parametrici nel rilevare la vera dimensionalità dei dati, soprattutto quando le dimensioni sono correlate o gli item saturano su più di una dimensione. Pertanto, i ricercatori dovrebbero utilizzare questo strumento con cautela e considerare un'ampia gamma di valori limite inferiori c per rivelare la vera struttura dei dati.</span>
<span id="cb36-125"><a href="#cb36-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-126"><a href="#cb36-126" aria-hidden="true" tabindex="-1"></a><span class="fu">## Monotonicità</span></span>
<span id="cb36-127"><a href="#cb36-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-128"><a href="#cb36-128" aria-hidden="true" tabindex="-1"></a>La monotonicità, un concetto chiave nelle scale Mokken, si riferisce alla relazione tra la posizione di una persona su una variabile latente (una caratteristica o tratto non direttamente osservabile) e la sua probabilità di rispondere correttamente a un item (domanda o affermazione). In sostanza, man mano che una persona si sposta verso livelli più elevati sulla variabile latente, la sua probabilità di dare una risposta corretta dovrebbe aumentare o rimanere la stessa, ma non diminuire. Questo principio si applica sia agli item con due possibili risposte (dicotomici) sia a quelli con più risposte (politomici).</span>
<span id="cb36-129"><a href="#cb36-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-130"><a href="#cb36-130" aria-hidden="true" tabindex="-1"></a>Per valutare la monotonicità, si utilizzano diversi metodi, tra cui l'analisi dei gruppi di restscore. Il "restscore" è il punteggio totale ottenuto da un individuo in un test, escludendo il punteggio dell'item specifico che si sta analizzando. Ad esempio, in un test di 10 item, se si vuole esaminare l'item numero 10, il restscore per ogni persona sarà il suo punteggio totale escludendo il punteggio ottenuto all'item 10. Di conseguenza, si creano diversi gruppi di restscore, che vanno da 0 a 9 in questo caso.</span>
<span id="cb36-131"><a href="#cb36-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-132"><a href="#cb36-132" aria-hidden="true" tabindex="-1"></a>La relazione tra restscore e monotonicità è la seguente: nei grafici, i gruppi di restscore sono confrontati con la percentuale di persone che hanno risposto correttamente all'item in questione all'interno di ogni gruppo. Idealmente, al crescere del restscore, la percentuale di risposte corrette dovrebbe aumentare o rimanere costante. Se i gruppi di restscore sono piccoli e quindi non forniscono stime affidabili, possono essere combinati con gruppi adiacenti per ottenere dimensioni maggiori e stime più precise.</span>
<span id="cb36-133"><a href="#cb36-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-134"><a href="#cb36-134" aria-hidden="true" tabindex="-1"></a>Il restscore funge da sostituto per θ, la posizione sulla variabile latente. Se la monotonicità è rispettata, ci si aspetta che la percentuale di risposte corrette aumenti (o almeno rimanga costante) man mano che aumenta il restscore. In altre parole, persone con un restscore più alto dovrebbero avere una probabilità maggiore di rispondere correttamente rispetto a quelle con un restscore più basso. Questa aspettativa dovrebbe essere valida per tutte le coppie di gruppi di restscore.</span>
<span id="cb36-135"><a href="#cb36-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-136"><a href="#cb36-136" aria-hidden="true" tabindex="-1"></a>L'analisi delle Funzioni di Risposta all'Item (IRF) è particolarmente utile perché permette di osservare come la performance degli item varia lungo il continuum del tratto latente. A differenza dell'IRT parametrico, dove l'attenzione è sulla stima dei parametri, l'IRT non parametrico (NIRT) si concentra sui metodi grafici, che sono fondamentali per comprendere come gli item funzionino a diversi livelli del tratto latente.</span>
<span id="cb36-137"><a href="#cb36-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-138"><a href="#cb36-138" aria-hidden="true" tabindex="-1"></a>Per gli item politomici, la monotonicità è valutata sia complessivamente sia all'interno delle singole categorie di risposta. Inoltre, si utilizzano i coefficienti di scalabilità per valutare la monotonicità. Se il Modello di Omoegeneità Monotona (MHM) è valido, le covarianze tra tutte le coppie di item (Hij) devono essere non negative. Tuttavia, Hij non negativi non sono una condizione sufficiente per garantire IRFs non decrescenti e non assicurano l'adattamento al MHM. Nella pratica, item con valori di Hi superiori a .30 sono generalmente considerati accettabili.</span>
<span id="cb36-139"><a href="#cb36-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-140"><a href="#cb36-140" aria-hidden="true" tabindex="-1"></a><span class="fu">## Ordinamento Invariante degli Item</span></span>
<span id="cb36-141"><a href="#cb36-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-142"><a href="#cb36-142" aria-hidden="true" tabindex="-1"></a>In contesti psicologici ed educativi, la definizione della difficoltà degli item di un test è cruciale. Generalmente, questa difficoltà viene determinata attraverso le medie degli item nella popolazione target. Tuttavia, è importante considerare che l'ordine di difficoltà derivato dalle risposte medie della popolazione potrebbe non essere universale per ogni individuo.</span>
<span id="cb36-143"><a href="#cb36-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-144"><a href="#cb36-144" aria-hidden="true" tabindex="-1"></a>Il concetto di Ordinamento Invariante degli Item (IIO) si riferisce alla necessità che l'ordine di difficoltà degli item rimanga consistente tra diversi sottogruppi di persone. Questo aspetto è fondamentale per garantire che i confronti tra i gruppi basati sui punteggi totali siano validi e che le differenze nei punteggi totali abbiano un significato reale. In ambito psicologico, ad esempio nei questionari sulla depressione o sull'ansia, l'IIO implica che un individuo con un punteggio totale più alto manifesti tutti i sintomi di una persona con un punteggio inferiore, oltre a sintomi aggiuntivi.</span>
<span id="cb36-145"><a href="#cb36-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-146"><a href="#cb36-146" aria-hidden="true" tabindex="-1"></a>L'IIO è altresì desiderabile quando si ordinano gli item di un test da quelli più facili a quelli più difficili, per garantire che questa progressione sia valida per tutti gli esaminandi. In altre parole, un item considerato facile dovrebbe essere tale per tutti i partecipanti, così come un item difficile dovrebbe rappresentare una sfida per tutti.</span>
<span id="cb36-147"><a href="#cb36-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-148"><a href="#cb36-148" aria-hidden="true" tabindex="-1"></a>Un ordinamento degli item che non rispetta l'IIO indica una variazione nella difficoltà degli item tra diversi gruppi. Questo può suggerire una funzione differenziale dell'item (DIF) o un bias, rendendo problematico ordinare gli item in base alla loro difficoltà.</span>
<span id="cb36-149"><a href="#cb36-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-150"><a href="#cb36-150" aria-hidden="true" tabindex="-1"></a>Per valutare l'IIO, si utilizzano diverse tecniche come il metodo dei gruppi di restscore, il metodo di divisione degli item, le matrici delle proporzioni P(++)/P(--), e il metodo di divisione dei restscore. Queste procedure aiutano a determinare se l'ordine di difficoltà degli item è coerente attraverso diversi gruppi.</span>
<span id="cb36-151"><a href="#cb36-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-152"><a href="#cb36-152" aria-hidden="true" tabindex="-1"></a>In conclusione, l'IIO è essenziale sia per la teoria della misurazione sia per l'interpretazione accurata dei punteggi dei test. Pur essendo un presupposto fondamentale nell'uso degli strumenti di misurazione, l'IIO spesso non viene verificato empiricamente. La sua conferma è particolarmente importante nei test che mirano a riflettere una struttura gerarchica o cumulativa dei tratti misurati. Per trarre conclusioni affidabili sui processi cognitivi evolutivi basati sull'ordine di difficoltà degli item, è cruciale dimostrare la validità dell'IIO.</span>
<span id="cb36-153"><a href="#cb36-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-154"><a href="#cb36-154" aria-hidden="true" tabindex="-1"></a><span class="fu">## Dimensione del Campione </span></span>
<span id="cb36-155"><a href="#cb36-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-156"><a href="#cb36-156" aria-hidden="true" tabindex="-1"></a>Nel campo della psicometria, determinare la dimensione minima di un campione per i test statistici è un'area ben stabilita. Tuttavia, per quanto riguarda l'Analisi delle Scale Mokken (MSA), questo è un ambito ancora poco esplorato e ci sono pochi studi a riguardo. La ricerca in questo settore è necessaria per evitare sia la capitalizzazione sul caso sia l'utilizzo di campioni eccessivamente grandi, specialmente quando le risorse e il tempo a disposizione dei ricercatori sono limitati.</span>
<span id="cb36-157"><a href="#cb36-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-158"><a href="#cb36-158" aria-hidden="true" tabindex="-1"></a>La "capitalizzazione sul caso" si riferisce a una condizione in cui una scala di Mokken viene identificata casualmente quando, in realtà, tale scala non esiste e ciò è dovuto alla ridotta dimensione del campione. Al contrario, può anche accadere che una scala esistente non venga identificata.</span>
<span id="cb36-159"><a href="#cb36-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-160"><a href="#cb36-160" aria-hidden="true" tabindex="-1"></a>Uno studio condotto da Straat et al. (2014) ha esaminato le dimensioni minime del campione necessarie per l'Automated Item Selection Procedure (AISP) e per l'algoritmo genetico (GA). Lo studio ha valutato l'impatto di diversi fattori, inclusa la lunghezza del test, i valori approssimativi dei coefficienti di scalabilità (Hi) degli item e la correlazione tra le dimensioni nella scala. I risultati hanno evidenziato che la dimensione del campione necessaria dipende da tutti questi fattori. Tuttavia, il fattore più influente è risultato essere il valore di Hi. Con l'aumento di Hi, erano necessarie dimensioni di campione più piccole per assegnare correttamente gli item alle scale appropriate. La lunghezza del test non ha avuto un grande impatto sulla precisione della classificazione degli item nelle scale corrette. Tuttavia, le correlazioni tra le dimensioni hanno avuto qualche effetto in combinazione con vari livelli di Hi. Per valori di Hi intorno a .22, sono necessarie dimensioni di campione di 750-1000 persone per ottenere una precisione mediocre o adeguata, e di 1250-2500 persone per una precisione buona o eccellente. Con valori di Hi di .42, per una precisione mediocre o adeguata sono necessarie dimensioni di campione di 50 persone, mentre per una precisione buona o eccellente, la dimensione del campione dovrebbe essere di almeno 250. Quando le correlazioni tra le due dimensioni erano alte (ad esempio, .60) e i valori di Hi erano .42, erano necessarie dimensioni di campione maggiori per assegnare correttamente gli item alle scale rispetto alla condizione in cui le correlazioni erano .30 o 1.</span>
<span id="cb36-161"><a href="#cb36-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-162"><a href="#cb36-162" aria-hidden="true" tabindex="-1"></a>Un altro studio condotto da Watson et al. (2018) ha indagato l'impatto della dimensione del campione sui coefficienti di scalabilità utilizzando dati reali. Hanno estratto campioni di 50, 250, 500, 600, 750 e 1000 persone da un campione più ampio di 7510 persone che hanno risposto a un questionario di 14 item con item a 5 punti Likert. Utilizzando il bootstrapping, hanno estratto 1000 campioni per ogni dimensione del campione. I risultati hanno mostrato che i valori medi di H e Hi non cambiavano notevolmente tra le diverse dimensioni del campione. Tuttavia, considerando gli intervalli di confidenza al 95%, dimensioni di campione più piccole hanno portato a un maggior numero di occasioni in cui il limite inferiore degli intervalli di confidenza al 95% per Hi era inferiore a .30. Ad esempio, per N=50, il numero di volte in cui il limite inferiore degli intervalli di confidenza per Hi era inferiore a .30 era 592, mentre per N=1000, questo numero era zero. Ciò significa che, basandosi sugli errori standard di Hi, quando N=50, in 592 casi su 1000 si dovrebbe rifiutare l'item, concludendo che il suo Hi potrebbe essere inferiore a .30. Tuttavia, i valori medi di Hi per N=50 e N=1000 erano esattamente gli stessi. Questo suggerisce che la dimensione del campione non influisce sulle stime puntuali dei coefficienti di scalabilità, ma gioca un ruolo cruciale quando si considerano gli errori standard dei coefficienti di scalabilità e gli intervalli di confidenza per decidere sulla qualità degli item.</span>
<span id="cb36-163"><a href="#cb36-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-164"><a href="#cb36-164" aria-hidden="true" tabindex="-1"></a>In conclusione, questi studi evidenziano l'importanza di considerare la dimensione del campione nell'analisi delle Scale Mokken. Mentre i valori medi di scalabilità possono non variare significativamente con la dimensione del campione, la precisione e l'affidabilità delle stime, così come la capacità di trarre conclusioni affidabili sulla qualità degli item, sono influenzate dalla grandezza del campione. Pertanto, è fondamentale scegliere una dimensione di campione adeguata per garantire risultati validi e affidabili nelle scale di Mokken. Questo è particolarmente critico in situazioni dove risorse e tempo sono limitati, e una scelta accurata della dimensione del campione può contribuire a un utilizzo più efficiente di tali risorse.</span>
<span id="cb36-165"><a href="#cb36-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-166"><a href="#cb36-166" aria-hidden="true" tabindex="-1"></a><span class="fu">## Il Contributo della MSA alla Validazione dei Test</span></span>
<span id="cb36-167"><a href="#cb36-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-168"><a href="#cb36-168" aria-hidden="true" tabindex="-1"></a>Nell'ambito dell'Analisi delle Scale Mokken (MSA), la validità del modello di omogeneità monotona è cruciale. Questo modello è confermato quando le assunzioni fondamentali di unidimensionalità, monotonicità e indipendenza locale sono rispettate. In particolare, se i coefficienti di scalabilità H, Hi e Hij risultano positivi e significativamente superiori a zero (o meglio ancora, superiori a .30), ciò indica che i dati si conformano efficacemente a una struttura di Guttman. Tale conformità fornisce una forte indicazione dell'esistenza di un costrutto unidimensionale.</span>
<span id="cb36-169"><a href="#cb36-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-170"><a href="#cb36-170" aria-hidden="true" tabindex="-1"></a>L'adeguamento al modello di omogeneità monotona implica inoltre la presenza di monotonicità. Ciò significa che deve esistere una relazione non decrescente tra la variabile latente θ e la probabilità di ottenere una risposta corretta. Questo concetto è perfettamente in linea con il secondo criterio di validità nell'approccio basato sugli strumenti, secondo il quale variazioni nel tratto latente dovrebbero produrre variazioni corrispondenti nelle risposte agli item.</span>
<span id="cb36-171"><a href="#cb36-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-172"><a href="#cb36-172" aria-hidden="true" tabindex="-1"></a>Un'ulteriore dimensione della MSA è il modello di doppia monotonicità, che introduce l'assunzione dell'Ordinamento Invariante degli Item (IIO). Secondo questa assunzione, le Funzioni di Risposta all'Item (IRF) degli item di un test non dovrebbero intersecarsi. Anche se una sua violazione non rende di per sé un test invalido secondo l'approccio basato sugli strumenti, la conformità all'IIO migliora notevolmente l'interpretabilità dei punteggi del test. Inoltre, la violazione dell'IIO è analoga alla presenza di funzione differenziale dell'item (DIF) nei modelli IRT parametrici.</span>
<span id="cb36-173"><a href="#cb36-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-174"><a href="#cb36-174" aria-hidden="true" tabindex="-1"></a>In conclusione, la MSA si rivela uno strumento estremamente utile e potente per la validazione di test in ambiti psicologici ed educativi. La capacità della MSA di confermare il modello di omogeneità monotona attraverso i coefficienti di scalabilità offre una valida evidenza che i test misurano effettivamente il costrutto unidimensionale che intendono valutare. Questo aspetto è fondamentale per garantire che i punteggi dei test riflettano veramente le capacità o le caratteristiche misurate.</span>
<span id="cb36-175"><a href="#cb36-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-176"><a href="#cb36-176" aria-hidden="true" tabindex="-1"></a>L'incorporazione dell'Ordinamento Invariante degli Item (IIO) nel modello di doppia monotonicità aggiunge un ulteriore livello di rigorosità. Assicurandosi che le IRF degli item non si intersechino, si aumenta la precisione con cui il test misura il costrutto e si migliora l'interpretazione dei punteggi. Questo approccio riduce il rischio di bias e garantisce che il test sia equamente rappresentativo per tutti i partecipanti, indipendentemente dalle loro caratteristiche individuali.</span>
<span id="cb36-177"><a href="#cb36-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-178"><a href="#cb36-178" aria-hidden="true" tabindex="-1"></a>Inoltre, la MSA fornisce una base solida per affermare che le variazioni nei punteggi dei test sono effettivamente causate da variazioni nel costrutto misurato. Questa caratteristica rende la MSA particolarmente preziosa in contesti dove è essenziale dimostrare una relazione causale tra il costrutto e i punteggi del test.</span>
<span id="cb36-179"><a href="#cb36-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-180"><a href="#cb36-180" aria-hidden="true" tabindex="-1"></a>In sintesi, l'impiego della MSA nella validazione dei test non solo rafforza la fiducia nella precisione e nell'affidabilità dei test stessi, ma contribuisce anche a una maggiore chiarezza e trasparenza nell'interpretazione dei risultati. </span>
<span id="cb36-181"><a href="#cb36-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-182"><a href="#cb36-182" aria-hidden="true" tabindex="-1"></a><span class="fu">## Critiche alla MSA</span></span>
<span id="cb36-183"><a href="#cb36-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-184"><a href="#cb36-184" aria-hidden="true" tabindex="-1"></a>Negli anni '80, l'Analisi delle Scale Mokken (MSA) è stata criticata per la limitata applicabilità del coefficiente di scalabilità H, ritenuto dipendente dalle caratteristiche del campione e degli item, e non adeguato come misura di adattamento del modello. Ulteriori critiche hanno riguardato il coefficiente di scalabilità degli item Hi, accusato di selezionare solo item con IRF ripide e distanti, escludendo item validi e riducendo la varianza e l'affidabilità del test. I critici hanno anche messo in dubbio l'adeguatezza della MSA per l'ordinamento libero degli item secondo il rango latente, suggerendo una possibile necessità del modello di Rasch.</span>
<span id="cb36-185"><a href="#cb36-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-186"><a href="#cb36-186" aria-hidden="true" tabindex="-1"></a>In risposta, i difensori della MSA hanno sottolineato che le critiche si basano su una lettura selettiva e una mancata comprensione dei modelli non parametrici. Hanno ribadito che H e Hi sono intesi come misure dell'omogeneità monotona, e non come indici di doppia monotonia, e che la dipendenza di H dalla varianza della popolazione è in linea con le assunzioni del modello. Questo dibattito evidenzia l'importanza di valutare attentamente i metodi statistici come la MSA nel loro contesto di applicazione.</span>
<span id="cb36-187"><a href="#cb36-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-188"><a href="#cb36-188" aria-hidden="true" tabindex="-1"></a><span class="fu">## Considerazioni Conclusive</span></span>
<span id="cb36-189"><a href="#cb36-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-190"><a href="#cb36-190" aria-hidden="true" tabindex="-1"></a>In questo capitolo, abbiamo esplorato una questione fondamentale nella misurazione psicologica: l'efficacia dei punteggi totali grezzi nell'ordinare gli esaminandi. Tradizionalmente, tali punteggi vengono utilizzati per classificare i soggetti, da quelli più competenti a quelli meno competenti, da quelli più ansiosi a quelli meno ansiosi, o da quelli più depressi a quelli meno depressi. Sebbene sia comunemente accettato che i punteggi grezzi siano dati su scala ordinale, molti ricercatori li trattano come se fossero su scala intervallo. Ciò significa che, utilizzando i punteggi grezzi, si può solamente stabilire l'ordine dei rispondenti, ma non discernere le differenze tra di loro.</span>
<span id="cb36-191"><a href="#cb36-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-192"><a href="#cb36-192" aria-hidden="true" tabindex="-1"></a>Il tema principale affrontato in questo capitolo è che i punteggi grezzi potrebbero non essere nemmeno dati ordinali. In altre parole, i punteggi totali grezzi potrebbero non essere sufficientemente affidabili per ordinare gli esaminandi. Affinché i punteggi grezzi siano considerati ordinali, i pattern di risposta devono adattarsi al Modello di Omogeneità Monotona (MHM). Nella teoria classica dei test, si assume che i punteggi totali siano ordinali senza verificarlo. Il MHM, come modello IRT non parametrico, ci permette di testare se i punteggi totali rispettano l'assioma di una scala ordinale. Lo stesso vale per gli item: l'adattamento al Modello di Doppia Monotonicità (DMM) ci permette di ordinare gli item in base alle loro proporzioni di risposte corrette (valore p).</span>
<span id="cb36-193"><a href="#cb36-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-194"><a href="#cb36-194" aria-hidden="true" tabindex="-1"></a>In questo capitolo, abbiamo discusso le procedure conosciute collettivamente come Analisi delle Scale Mokken, per testare l'adattamento dei dati al MHM e al DMM. Queste analisi offrono strumenti preziosi per verificare l'affidabilità e la validità dei punteggi totali grezzi utilizzati in una vasta gamma di contesti psicologici.</span>
<span id="cb36-195"><a href="#cb36-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-196"><a href="#cb36-196" aria-hidden="true" tabindex="-1"></a><span class="fu">## Formule di Calcolo </span></span>
<span id="cb36-197"><a href="#cb36-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-198"><a href="#cb36-198" aria-hidden="true" tabindex="-1"></a>Per sviluppare un'intuizione più precisa dello scaling di Mokken, consideriamo nei dettagli il calcolo di alcuni dei suoi indici fondamentali.</span>
<span id="cb36-199"><a href="#cb36-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-200"><a href="#cb36-200" aria-hidden="true" tabindex="-1"></a><span class="fu">## Coefficienti di Scalabilità Singoli ($H_i$) nello Scaling di Mokken</span></span>
<span id="cb36-201"><a href="#cb36-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-202"><a href="#cb36-202" aria-hidden="true" tabindex="-1"></a>Esaminiamo il coefficiente di scalabilità singolo, denotato come $H_i$, il quale  misura la qualità di un singolo item in uno scaling di Mokken. Un valore elevato di $H_i$ indica che l'item discrimina bene tra gli esaminandi e contribuisce efficacemente all'ordinamento degli stessi. </span>
<span id="cb36-203"><a href="#cb36-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-204"><a href="#cb36-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-205"><a href="#cb36-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-206"><a href="#cb36-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-207"><a href="#cb36-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-208"><a href="#cb36-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-209"><a href="#cb36-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-210"><a href="#cb36-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-211"><a href="#cb36-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-212"><a href="#cb36-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-213"><a href="#cb36-213" aria-hidden="true" tabindex="-1"></a>Le soglie generalmente accettate per i coefficienti di scalabilità singoli ($H_i$)  sono le seguenti:</span>
<span id="cb36-214"><a href="#cb36-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-215"><a href="#cb36-215" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**$H_i \geq 0.30$**: Considerato accettabile. L'item discrimina abbastanza bene e contribuisce all'ordinamento degli esaminandi.</span>
<span id="cb36-216"><a href="#cb36-216" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**$H_i \geq 0.40$**: Considerato buono. L'item ha una buona capacità di discriminazione.</span>
<span id="cb36-217"><a href="#cb36-217" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**$H_i \geq 0.50$**: Considerato molto buono. L'item ha un'ottima capacità di discriminazione.</span>
<span id="cb36-218"><a href="#cb36-218" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-219"><a href="#cb36-219" aria-hidden="true" tabindex="-1"></a><span class="fu">### Formula per Calcolare $H_i$</span></span>
<span id="cb36-220"><a href="#cb36-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-221"><a href="#cb36-221" aria-hidden="true" tabindex="-1"></a>La formula per calcolare il coefficiente di scalabilità singolo $H_i$ di un item $i$ è:</span>
<span id="cb36-222"><a href="#cb36-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-223"><a href="#cb36-223" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb36-224"><a href="#cb36-224" aria-hidden="true" tabindex="-1"></a>H_i = \frac{ \sum_{j \neq i} H_{ij} }{ n - 1 },</span>
<span id="cb36-225"><a href="#cb36-225" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb36-226"><a href="#cb36-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-227"><a href="#cb36-227" aria-hidden="true" tabindex="-1"></a>dove $H_{ij}$ è il coefficiente di scalabilità di coppia tra l'item $i$ e l'item $j$, e $n$ è il numero totale di item. Il coefficiente di scalabilità di coppia $H_{ij}$ è definito come:</span>
<span id="cb36-228"><a href="#cb36-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-229"><a href="#cb36-229" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb36-230"><a href="#cb36-230" aria-hidden="true" tabindex="-1"></a>H_{ij} = \frac{ \text{cov}(X_i, X_j) }{ \text{min} <span class="co">[</span><span class="ot">\text{var}(X_i), \text{var}(X_j)</span><span class="co">]</span> },</span>
<span id="cb36-231"><a href="#cb36-231" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb36-232"><a href="#cb36-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-233"><a href="#cb36-233" aria-hidden="true" tabindex="-1"></a>dove:</span>
<span id="cb36-234"><a href="#cb36-234" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$X_i$ e $X_j$ sono le risposte agli item $i$ e $j$.</span>
<span id="cb36-235"><a href="#cb36-235" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\text{cov}(X_i, X_j)$ è la covarianza tra gli item $i$ e $j$.</span>
<span id="cb36-236"><a href="#cb36-236" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\text{var}(X_i)$ e $\text{var}(X_j)$ sono le varianze degli item $i$ e $j$.</span>
<span id="cb36-237"><a href="#cb36-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-238"><a href="#cb36-238" aria-hidden="true" tabindex="-1"></a>Intuitivamente, $H_i$ misura quanto bene l'item $i$ contribuisce all'ordine totale degli esaminandi basato sui punteggi totali. Se un item ha un $H_i$ elevato, significa che le risposte a questo item sono ben correlate con le risposte agli altri item, suggerendo che discrimina efficacemente tra esaminandi con punteggi diversi.</span>
<span id="cb36-239"><a href="#cb36-239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-240"><a href="#cb36-240" aria-hidden="true" tabindex="-1"></a>Per calcolare i coefficienti di scalabilità singoli $H_i$ in R, possiamo utilizzare il pacchetto <span class="in">`mokken`</span>.</span>
<span id="cb36-241"><a href="#cb36-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-242"><a href="#cb36-242" aria-hidden="true" tabindex="-1"></a><span class="in">```r</span></span>
<span id="cb36-243"><a href="#cb36-243" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mokken)</span>
<span id="cb36-244"><a href="#cb36-244" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-245"><a href="#cb36-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-246"><a href="#cb36-246" aria-hidden="true" tabindex="-1"></a>Consideriamo un set di dati relativi all'Adjective Checklist (ACL), che consiste of 300 adjectives and adjectival phrases commonly used to describe a person's personality. Consideriamo la sottoscala Communality.</span>
<span id="cb36-247"><a href="#cb36-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-250"><a href="#cb36-250" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb36-251"><a href="#cb36-251" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(acl)   </span>
<span id="cb36-252"><a href="#cb36-252" aria-hidden="true" tabindex="-1"></a>Communality <span class="ot">&lt;-</span> acl[,<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>]</span>
<span id="cb36-253"><a href="#cb36-253" aria-hidden="true" tabindex="-1"></a>Communality <span class="sc">|&gt;</span> <span class="fu">head</span>()</span>
<span id="cb36-254"><a href="#cb36-254" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-255"><a href="#cb36-255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-258"><a href="#cb36-258" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb36-259"><a href="#cb36-259" aria-hidden="true" tabindex="-1"></a>scalability <span class="ot">&lt;-</span> <span class="fu">coefH</span>(Communality)</span>
<span id="cb36-260"><a href="#cb36-260" aria-hidden="true" tabindex="-1"></a>scalability<span class="sc">$</span>Hi</span>
<span id="cb36-261"><a href="#cb36-261" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-262"><a href="#cb36-262" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-263"><a href="#cb36-263" aria-hidden="true" tabindex="-1"></a>In questo esempio, gli item con $H_i$ superiori a 0.30 sono considerati accettabili, indicando che questi item contribuiscono efficacemente all'ordinamento degli esaminandi.</span>
<span id="cb36-264"><a href="#cb36-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-265"><a href="#cb36-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-266"><a href="#cb36-266" aria-hidden="true" tabindex="-1"></a><span class="fu">### Coefficiente di Scalabilità di Coppia ($ H_{ij} $) nello Scaling di Mokken</span></span>
<span id="cb36-267"><a href="#cb36-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-268"><a href="#cb36-268" aria-hidden="true" tabindex="-1"></a>Il coefficiente di scalabilità di coppia $H_{ij}$ misura la qualità della relazione tra due item specifici all'interno di uno scaling di Mokken. Questo coefficiente è utile per valutare quanto bene due item discriminano insieme tra gli esaminandi.</span>
<span id="cb36-269"><a href="#cb36-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-270"><a href="#cb36-270" aria-hidden="true" tabindex="-1"></a><span class="fu">### Formula per Calcolare $ H_{ij} $</span></span>
<span id="cb36-271"><a href="#cb36-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-272"><a href="#cb36-272" aria-hidden="true" tabindex="-1"></a>La formula per calcolare il coefficiente di scalabilità di coppia $ H_{ij} $ tra due item $ i $ e $ j $ è:</span>
<span id="cb36-273"><a href="#cb36-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-274"><a href="#cb36-274" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb36-275"><a href="#cb36-275" aria-hidden="true" tabindex="-1"></a>H_{ij} = \frac{P(X_i = X_j) - P(X_i \neq X_j)}{1 - P(X_i \neq X_j)},</span>
<span id="cb36-276"><a href="#cb36-276" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb36-277"><a href="#cb36-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-278"><a href="#cb36-278" aria-hidden="true" tabindex="-1"></a>dove:</span>
<span id="cb36-279"><a href="#cb36-279" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$ P(X_i = X_j) $ è la probabilità che le risposte agli item $ i $ e $ j $ siano uguali.</span>
<span id="cb36-280"><a href="#cb36-280" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$ P(X_i \neq X_j) $ è la probabilità che le risposte agli item $ i $ e $ j $ siano diverse.</span>
<span id="cb36-281"><a href="#cb36-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-282"><a href="#cb36-282" aria-hidden="true" tabindex="-1"></a>Intuitivamente, $ H_{ij} $ misura quanto bene i due item $ i $ e $ j $ lavorano insieme per discriminare tra gli esaminandi. Un valore elevato di $ H_{ij} $ indica che i due item hanno una buona covarianza e che la loro variabilità è tale da contribuire efficacemente all'ordinamento degli esaminandi.</span>
<span id="cb36-283"><a href="#cb36-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-284"><a href="#cb36-284" aria-hidden="true" tabindex="-1"></a>Le soglie generalmente accettate per i coefficienti di scalabilità di coppia ($H_{ij}$) sono le seguenti:</span>
<span id="cb36-285"><a href="#cb36-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-286"><a href="#cb36-286" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**$H_{ij} \geq 0.30$**: Considerato accettabile. La coppia di item discrimina abbastanza bene insieme.</span>
<span id="cb36-287"><a href="#cb36-287" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**$H_{ij} \geq 0.40$**: Considerato buono. La coppia di item ha una buona capacità di discriminazione congiunta.</span>
<span id="cb36-288"><a href="#cb36-288" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**$H_{ij} \geq 0.50$**: Considerato molto buono. La coppia di item ha un'ottima capacità di discriminazione congiunta.</span>
<span id="cb36-289"><a href="#cb36-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-290"><a href="#cb36-290" aria-hidden="true" tabindex="-1"></a>Per calcolare i coefficienti di scalabilità di coppia $ H_{ij} $ in R, possiamo utilizzare nuovamente la funzione <span class="in">`coefH`</span> del pacchetto <span class="in">`mokken`</span>.</span>
<span id="cb36-291"><a href="#cb36-291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-292"><a href="#cb36-292" aria-hidden="true" tabindex="-1"></a>Nei dati dell'esempio precedente, $ H_{ij} $ per ciascuna coppia di item è riportato nella matrice. </span>
<span id="cb36-293"><a href="#cb36-293" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-294"><a href="#cb36-294" aria-hidden="true" tabindex="-1"></a><span class="fu">### Coefficiente di Scalabilità per l’Intero Test ($ H $) </span></span>
<span id="cb36-295"><a href="#cb36-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-296"><a href="#cb36-296" aria-hidden="true" tabindex="-1"></a>Il coefficiente di scalabilità per l’intero test ($ H $) misura la qualità complessiva di un set di item in termini di capacità di discriminazione e di ordinamento degli esaminandi. Un valore elevato di $ H $ indica che il test, nel suo insieme, discrimina bene tra gli esaminandi.</span>
<span id="cb36-297"><a href="#cb36-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-298"><a href="#cb36-298" aria-hidden="true" tabindex="-1"></a>La formula per calcolare il coefficiente di scalabilità per l'intero test è:</span>
<span id="cb36-299"><a href="#cb36-299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-300"><a href="#cb36-300" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb36-301"><a href="#cb36-301" aria-hidden="true" tabindex="-1"></a>H = \frac{\sum_{i &lt; j} H_{ij}}{\sum_{i &lt; j} H_{ij}^{\text{max}}} ,</span>
<span id="cb36-302"><a href="#cb36-302" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb36-303"><a href="#cb36-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-304"><a href="#cb36-304" aria-hidden="true" tabindex="-1"></a>dove:</span>
<span id="cb36-305"><a href="#cb36-305" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$ H_{ij} $ è il coefficiente di scalabilità di coppia tra gli item $ i $ e $ j $.</span>
<span id="cb36-306"><a href="#cb36-306" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$ H_{ij}^{\text{max}} $ è il massimo valore teorico di $ H_{ij} $.</span>
<span id="cb36-307"><a href="#cb36-307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-308"><a href="#cb36-308" aria-hidden="true" tabindex="-1"></a>Intuitivamente, $ H $ misura quanto bene l'intero set di item lavora insieme per discriminare tra gli esaminandi. Un valore elevato di $ H $ indica che, complessivamente, gli item hanno una buona capacità di discriminazione e contribuiscono efficacemente all'ordinamento degli esaminandi.</span>
<span id="cb36-309"><a href="#cb36-309" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-310"><a href="#cb36-310" aria-hidden="true" tabindex="-1"></a>Le soglie comunemente utilizzate per interpretare $ H $ sono:</span>
<span id="cb36-311"><a href="#cb36-311" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**$ H \geq 0.30 $**: Considerato accettabile.</span>
<span id="cb36-312"><a href="#cb36-312" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**$ H \geq 0.40 $**: Considerato buono.</span>
<span id="cb36-313"><a href="#cb36-313" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**$ H \geq 0.50 $**: Considerato molto buono.</span>
<span id="cb36-314"><a href="#cb36-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-315"><a href="#cb36-315" aria-hidden="true" tabindex="-1"></a>Per calcolare il coefficiente di scalabilità per l'intero test ($ H $) in R, possiamo utilizzare nuovamente la funzione <span class="in">`coefH()`</span> del pacchetto <span class="in">`mokken`</span>.</span>
<span id="cb36-316"><a href="#cb36-316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-317"><a href="#cb36-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-320"><a href="#cb36-320" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb36-321"><a href="#cb36-321" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualizzare il coefficiente di scalabilità per l'intero test</span></span>
<span id="cb36-322"><a href="#cb36-322" aria-hidden="true" tabindex="-1"></a>H_test <span class="ot">&lt;-</span> scalability<span class="sc">$</span>H</span>
<span id="cb36-323"><a href="#cb36-323" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(H_test)</span>
<span id="cb36-324"><a href="#cb36-324" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-325"><a href="#cb36-325" aria-hidden="true" tabindex="-1"></a>Il valore del coefficiente di scalabilità per l’intero test ($ H $) di 0.264 indica che la qualità complessiva della sottoscala Communality è scarsa.</span>
<span id="cb36-326"><a href="#cb36-326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-327"><a href="#cb36-327" aria-hidden="true" tabindex="-1"></a><span class="fu">### Monotonicità nello Scaling di Mokken</span></span>
<span id="cb36-328"><a href="#cb36-328" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-329"><a href="#cb36-329" aria-hidden="true" tabindex="-1"></a>Nello scaling di Mokken, la monotonicità è una proprietà desiderabile che implica che la probabilità di rispondere correttamente a un item aumenta con il livello del tratto latente misurato dal test. In altre parole, per gli item di un test che misurano lo stesso costrutto, gli esaminandi con punteggi più alti sul tratto latente dovrebbero avere una probabilità maggiore di rispondere correttamente a ciascun item rispetto a quelli con punteggi più bassi.</span>
<span id="cb36-330"><a href="#cb36-330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-331"><a href="#cb36-331" aria-hidden="true" tabindex="-1"></a>La funzione <span class="in">`check.monotonicity()`</span> del pacchetto <span class="in">`mokken`</span> in R viene utilizzata per verificare la presenza di violazioni della monotonicità per ciascun item in un set di dati. Essa esamina se la relazione tra la probabilità di rispondere correttamente a un item e il livello del tratto latente è monotona crescente.</span>
<span id="cb36-332"><a href="#cb36-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-333"><a href="#cb36-333" aria-hidden="true" tabindex="-1"></a>La funzione suddivide i punteggi totali degli esaminandi in gruppi (detti "gruppi di punteggio", "restscore") e verifica se la probabilità di rispondere correttamente a ciascun item aumenta con il punteggio del gruppo. Se la probabilità di risposta corretta diminuisce in uno o più gruppi, ciò costituisce una violazione della monotonicità.</span>
<span id="cb36-334"><a href="#cb36-334" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-337"><a href="#cb36-337" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb36-338"><a href="#cb36-338" aria-hidden="true" tabindex="-1"></a>monotonicity_results <span class="ot">&lt;-</span> <span class="fu">check.monotonicity</span>(Communality)</span>
<span id="cb36-339"><a href="#cb36-339" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(monotonicity_results)</span>
<span id="cb36-340"><a href="#cb36-340" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-341"><a href="#cb36-341" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-342"><a href="#cb36-342" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-343"><a href="#cb36-343" aria-hidden="true" tabindex="-1"></a>I risultati forniti dalla funzione <span class="in">`check.monotonicity()`</span> includono:</span>
<span id="cb36-344"><a href="#cb36-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-345"><a href="#cb36-345" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Numero di violazioni**: Il numero di violazioni della monotonicità per ciascun item.</span>
<span id="cb36-346"><a href="#cb36-346" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Indice di monotonicità**: Un indice che indica la forza della monotonicità per ciascun item.</span>
<span id="cb36-347"><a href="#cb36-347" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-348"><a href="#cb36-348" aria-hidden="true" tabindex="-1"></a>La colonna <span class="in">`#vi`</span> mostra il numero di violazioni della monotonicità per ciascun item.</span>
<span id="cb36-349"><a href="#cb36-349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-350"><a href="#cb36-350" aria-hidden="true" tabindex="-1"></a>Per avere una visione più chiara delle violazioni della monotonicità, è possibile creare dei grafici:</span>
<span id="cb36-351"><a href="#cb36-351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-354"><a href="#cb36-354" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb36-355"><a href="#cb36-355" aria-hidden="true" tabindex="-1"></a><span class="co"># Creare grafici delle violazioni di monotonicità</span></span>
<span id="cb36-356"><a href="#cb36-356" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(monotonicity_results)</span>
<span id="cb36-357"><a href="#cb36-357" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-358"><a href="#cb36-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-359"><a href="#cb36-359" aria-hidden="true" tabindex="-1"></a>I grafici generati dalla funzione <span class="in">`check.monotonicity()`</span> forniscono una rappresentazione visiva delle probabilità condizionali di rispondere correttamente a ciascun item rispetto ai punteggi totali degli esaminandi. I grafici generati dalla funzione <span class="in">`check.monotonicity()`</span> nel pacchetto <span class="in">`mokken`</span> per ciascun item mostrano due pannelli. Ecco come interpretarli:</span>
<span id="cb36-360"><a href="#cb36-360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-361"><a href="#cb36-361" aria-hidden="true" tabindex="-1"></a>Il pannello di sinistra mostra quattro spezzate che rappresentano la probabilità condizionale di rispondere correttamente all'item per ciascun gruppo di punteggio totale. Queste spezzate corrispondono ai seguenti concetti:</span>
<span id="cb36-362"><a href="#cb36-362" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-363"><a href="#cb36-363" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**E**: La probabilità empirica di rispondere correttamente all'item per ciascun gruppo di punteggio.</span>
<span id="cb36-364"><a href="#cb36-364" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**ER**: La probabilità empirica di rispondere correttamente all'item dopo aver applicato una regressione non parametrica.</span>
<span id="cb36-365"><a href="#cb36-365" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**M**: La probabilità media di rispondere correttamente all'item.</span>
<span id="cb36-366"><a href="#cb36-366" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**MR**: La probabilità media di rispondere correttamente all'item dopo aver applicato una regressione non parametrica.</span>
<span id="cb36-367"><a href="#cb36-367" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-368"><a href="#cb36-368" aria-hidden="true" tabindex="-1"></a>Queste spezzate aiutano a visualizzare come la probabilità di rispondere correttamente all'item varia rispetto al punteggio totale degli esaminandi.</span>
<span id="cb36-369"><a href="#cb36-369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-370"><a href="#cb36-370" aria-hidden="true" tabindex="-1"></a>Il pannello di destra mostra una singola spezzata che rappresenta la probabilità media condizionale di rispondere correttamente all'item per ciascun gruppo di punteggio totale. Questa spezzata è utile per verificare visivamente la presenza di violazioni della monotonicità.</span>
<span id="cb36-371"><a href="#cb36-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-372"><a href="#cb36-372" aria-hidden="true" tabindex="-1"></a>Interpretando correttamente queste linee, possiamo identificare eventuali violazioni della monotonicità e valutare la qualità degli item nel contesto dello scaling di Mokken.</span>
<span id="cb36-373"><a href="#cb36-373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-374"><a href="#cb36-374" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-375"><a href="#cb36-375" aria-hidden="true" tabindex="-1"></a><span class="fu">### Investigate the assumption of non-intersecting ISRFs using method restscore</span></span>
<span id="cb36-376"><a href="#cb36-376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-377"><a href="#cb36-377" aria-hidden="true" tabindex="-1"></a>La funzione <span class="in">`check.restscore()`</span> è utilizzata per verificare la coerenza degli item rispetto al punteggio residuo. In pratica, controlla se ogni item in una scala di Mokken soddisfa i requisiti di monotonicità e se contribuisce positivamente alla scala nel suo complesso.</span>
<span id="cb36-378"><a href="#cb36-378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-379"><a href="#cb36-379" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Monotonicità**: La monotonicità si riferisce al fatto che la probabilità di rispondere correttamente a un item dovrebbe aumentare con l'aumento del punteggio totale del soggetto.</span>
<span id="cb36-380"><a href="#cb36-380" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Punteggio residuo**: Il punteggio residuo per un item è calcolato sottraendo il punteggio dell'item dal punteggio totale del soggetto su tutti gli item della scala.</span>
<span id="cb36-381"><a href="#cb36-381" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-384"><a href="#cb36-384" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb36-385"><a href="#cb36-385" aria-hidden="true" tabindex="-1"></a><span class="co"># Investigate the assumption of non-intersecting ISRFs using method restscore</span></span>
<span id="cb36-386"><a href="#cb36-386" aria-hidden="true" tabindex="-1"></a>restscore.list <span class="ot">&lt;-</span> <span class="fu">check.restscore</span>(Communality)</span>
<span id="cb36-387"><a href="#cb36-387" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(restscore.list)</span>
<span id="cb36-388"><a href="#cb36-388" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(restscore.list)</span>
<span id="cb36-389"><a href="#cb36-389" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-390"><a href="#cb36-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-391"><a href="#cb36-391" aria-hidden="true" tabindex="-1"></a>Per interpretare i risultati ottenuti dal comando <span class="in">`summary(restscore.list)`</span> è utile comprendere il significato delle varie colonne e come queste possono informare sulla qualità degli item in una scala di Mokken.</span>
<span id="cb36-392"><a href="#cb36-392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-393"><a href="#cb36-393" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**ItemH**: Questo è l'indice di H per ciascun item. L'indice di H misura la forza della relazione tra l'item e il punteggio totale della scala. Valori più alti indicano una migliore coerenza con la scala. Tipicamente, un valore di H superiore a 0.3 è considerato buono.</span>
<span id="cb36-394"><a href="#cb36-394" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb36-395"><a href="#cb36-395" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**#ac**: Numero di soggetti che hanno risposto correttamente all'item (numero di osservazioni corrette).</span>
<span id="cb36-396"><a href="#cb36-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-397"><a href="#cb36-397" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**#vi**: Numero di violazioni della monotonicità per l'item. La monotonicità implica che la probabilità di rispondere correttamente a un item non diminuisce con l'aumento del punteggio totale del soggetto. Un numero elevato di violazioni è indicativo di problemi con l'item.</span>
<span id="cb36-398"><a href="#cb36-398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-399"><a href="#cb36-399" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**#vi/#ac**: Proporzione di violazioni rispetto al numero di osservazioni corrette. Valori più bassi indicano migliori proprietà di monotonicità.</span>
<span id="cb36-400"><a href="#cb36-400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-401"><a href="#cb36-401" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>**maxvi**: La massima violazione osservata della monotonicità per l'item. Valori più alti indicano maggiori problemi di monotonicità.</span>
<span id="cb36-402"><a href="#cb36-402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-403"><a href="#cb36-403" aria-hidden="true" tabindex="-1"></a><span class="ss">6. </span>**sum**: Somma delle violazioni. Fornisce un'indicazione del totale delle violazioni osservate per l'item.</span>
<span id="cb36-404"><a href="#cb36-404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-405"><a href="#cb36-405" aria-hidden="true" tabindex="-1"></a><span class="ss">7. </span>**sum/#ac**: Proporzione della somma delle violazioni rispetto al numero di osservazioni corrette.</span>
<span id="cb36-406"><a href="#cb36-406" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-407"><a href="#cb36-407" aria-hidden="true" tabindex="-1"></a><span class="ss">8. </span>**zmax**: Z-scores per l'indice di violazione massimo. Fornisce un'indicazione della significatività statistica delle violazioni.</span>
<span id="cb36-408"><a href="#cb36-408" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-409"><a href="#cb36-409" aria-hidden="true" tabindex="-1"></a><span class="ss">9. </span>**#zsig**: Numero di z-scores significativi. Indica quante delle violazioni sono statisticamente significative.</span>
<span id="cb36-410"><a href="#cb36-410" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-411"><a href="#cb36-411" aria-hidden="true" tabindex="-1"></a><span class="ss">10. </span>**crit**: Un valore critico che combina vari indicatori per valutare la qualità dell'item. Valori più alti possono indicare problemi con l'item.</span>
<span id="cb36-412"><a href="#cb36-412" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-413"><a href="#cb36-413" aria-hidden="true" tabindex="-1"></a>Consideriamo alcuni esempi specifici dall'output ottenuto per chiarire meglio.</span>
<span id="cb36-414"><a href="#cb36-414" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-415"><a href="#cb36-415" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**reliable**</span>
<span id="cb36-416"><a href="#cb36-416" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**ItemH**: 0.30 (buono)</span>
<span id="cb36-417"><a href="#cb36-417" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**#ac**: 432 (molti soggetti hanno risposto correttamente)</span>
<span id="cb36-418"><a href="#cb36-418" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**#vi**: 7 (pochi casi di violazioni)</span>
<span id="cb36-419"><a href="#cb36-419" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**#vi/#ac**: 0.02 (proporzione molto bassa)</span>
<span id="cb36-420"><a href="#cb36-420" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**maxvi**: 0.09 (violazione massima relativamente bassa)</span>
<span id="cb36-421"><a href="#cb36-421" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**sum**: 0.31 (totale violazioni basso)</span>
<span id="cb36-422"><a href="#cb36-422" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**sum/#ac**: 0.0007 (molto basso)</span>
<span id="cb36-423"><a href="#cb36-423" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**zmax**: 1.43 (nessuna violazione significativa, dato che **#zsig** è 0)</span>
<span id="cb36-424"><a href="#cb36-424" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**crit**: 26 (relativamente basso)</span>
<span id="cb36-425"><a href="#cb36-425" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-426"><a href="#cb36-426" aria-hidden="true" tabindex="-1"></a>   L'item "reliable" sembra avere una buona coerenza con la scala, con pochi problemi di monotonicità.</span>
<span id="cb36-427"><a href="#cb36-427" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-428"><a href="#cb36-428" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**unintelligent***</span>
<span id="cb36-429"><a href="#cb36-429" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**ItemH**: 0.12 (basso, indica che l'item non è molto coerente con la scala)</span>
<span id="cb36-430"><a href="#cb36-430" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**#ac**: 416</span>
<span id="cb36-431"><a href="#cb36-431" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**#vi**: 14 (numero relativamente alto di violazioni)</span>
<span id="cb36-432"><a href="#cb36-432" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**#vi/#ac**: 0.03 (proporzione più alta)</span>
<span id="cb36-433"><a href="#cb36-433" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**maxvi**: 0.11 (violazione massima più alta)</span>
<span id="cb36-434"><a href="#cb36-434" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**sum**: 0.86 (violazioni totali più alte)</span>
<span id="cb36-435"><a href="#cb36-435" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**sum/#ac**: 0.0021 (più alto rispetto ad altri item)</span>
<span id="cb36-436"><a href="#cb36-436" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**zmax**: 1.99 (significativo, dato che **#zsig** è 2)</span>
<span id="cb36-437"><a href="#cb36-437" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**crit**: 62 (più alto, indica problemi maggiori)</span>
<span id="cb36-438"><a href="#cb36-438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-439"><a href="#cb36-439" aria-hidden="true" tabindex="-1"></a>   L'item "unintelligent" presenta problemi significativi, con molte violazioni della monotonicità e un indice di H basso.</span>
<span id="cb36-440"><a href="#cb36-440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-441"><a href="#cb36-441" aria-hidden="true" tabindex="-1"></a>In generale, per ogni item, valori più bassi di **#vi**, **#vi/#ac**, **maxvi**, **sum**, **sum/#ac**, **zmax**, **#zsig** e **crit** indicano un item con buone proprietà psicometriche. Valori alti di **ItemH** indicano una forte coerenza con la scala complessiva. Gli item contrassegnati con un asterisco (*) sembrano avere problemi maggiori e potrebbero necessitare di ulteriori indagini o potenzialmente essere rimossi dalla scala.</span>
<span id="cb36-442"><a href="#cb36-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-443"><a href="#cb36-443" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-444"><a href="#cb36-444" aria-hidden="true" tabindex="-1"></a><span class="fu">### Proprietà dell'ordine di Mokken</span></span>
<span id="cb36-445"><a href="#cb36-445" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-446"><a href="#cb36-446" aria-hidden="true" tabindex="-1"></a>La funzione <span class="in">`check.pmatrix()`</span> è utilizzata per valutare la matrice delle probabilità (<span class="in">`pmatrix`</span>) degli item in una scala di Mokken. Essa verifica se gli item soddisfano la condizione di scalabilità, nota anche come proprietà dell'ordine di Mokken. Questa proprietà implica che gli item devono mostrare un pattern coerente di risposta in modo che, se un soggetto risponde correttamente a un item difficile, dovrebbe rispondere correttamente anche a tutti gli item più facili.</span>
<span id="cb36-447"><a href="#cb36-447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-450"><a href="#cb36-450" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb36-451"><a href="#cb36-451" aria-hidden="true" tabindex="-1"></a>pmatrix.list <span class="ot">&lt;-</span> <span class="fu">check.pmatrix</span>(Communality)</span>
<span id="cb36-452"><a href="#cb36-452" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(pmatrix.list)</span>
<span id="cb36-453"><a href="#cb36-453" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-454"><a href="#cb36-454" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-455"><a href="#cb36-455" aria-hidden="true" tabindex="-1"></a>L'output del comando <span class="in">`summary(pmatrix.list)`</span> ottenuto dalla funzione <span class="in">`check.pmatrix()`</span> del pacchetto <span class="in">`mokken`</span> fornisce vari indicatori che aiutano a valutare la qualità degli item in una scala di Mokken. </span>
<span id="cb36-456"><a href="#cb36-456" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-457"><a href="#cb36-457" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**ItemH**: Indice di scalabilità H per ciascun item. Valori più alti indicano una migliore coerenza con la scala. Tipicamente, un valore di H superiore a 0.3 è considerato buono.</span>
<span id="cb36-458"><a href="#cb36-458" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**#ac**: Numero di osservazioni considerate.</span>
<span id="cb36-459"><a href="#cb36-459" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**#vi**: Numero di violazioni della scalabilità per l'item. Una violazione si verifica quando la condizione di scalabilità non è rispettata.</span>
<span id="cb36-460"><a href="#cb36-460" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**#vi/#ac**: Proporzione di violazioni rispetto al numero di osservazioni considerate. Valori più bassi indicano migliori proprietà di scalabilità.</span>
<span id="cb36-461"><a href="#cb36-461" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>**maxvi**: La massima violazione osservata della scalabilità per l'item. Valori più alti indicano maggiori problemi di scalabilità.</span>
<span id="cb36-462"><a href="#cb36-462" aria-hidden="true" tabindex="-1"></a><span class="ss">6. </span>**sum**: Somma delle violazioni. Fornisce un'indicazione del totale delle violazioni osservate per l'item.</span>
<span id="cb36-463"><a href="#cb36-463" aria-hidden="true" tabindex="-1"></a><span class="ss">7. </span>**sum/#ac**: Proporzione della somma delle violazioni rispetto al numero di osservazioni considerate.</span>
<span id="cb36-464"><a href="#cb36-464" aria-hidden="true" tabindex="-1"></a><span class="ss">8. </span>**zmax**: Z-scores per l'indice di violazione massimo. Fornisce un'indicazione della significatività statistica delle violazioni.</span>
<span id="cb36-465"><a href="#cb36-465" aria-hidden="true" tabindex="-1"></a><span class="ss">9. </span>**#zsig**: Numero di z-scores significativi. Indica quante delle violazioni sono statisticamente significative.</span>
<span id="cb36-466"><a href="#cb36-466" aria-hidden="true" tabindex="-1"></a><span class="ss">10. </span>**crit**: Un valore critico che combina vari indicatori per valutare la qualità dell'item. Valori più alti possono indicare problemi con l'item.</span>
<span id="cb36-467"><a href="#cb36-467" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-468"><a href="#cb36-468" aria-hidden="true" tabindex="-1"></a>Consideriamo i due item esaminati in precedenza. </span>
<span id="cb36-469"><a href="#cb36-469" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-470"><a href="#cb36-470" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**reliable**</span>
<span id="cb36-471"><a href="#cb36-471" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**ItemH**: 0.30 (accettabile)</span>
<span id="cb36-472"><a href="#cb36-472" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**#ac**: 4608 (molti soggetti hanno risposto)</span>
<span id="cb36-473"><a href="#cb36-473" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**#vi**: 22 (numero di violazioni)</span>
<span id="cb36-474"><a href="#cb36-474" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**#vi/#ac**: 0.00 (proporzione molto bassa)</span>
<span id="cb36-475"><a href="#cb36-475" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**maxvi**: 0.05 (violazione massima relativamente bassa)</span>
<span id="cb36-476"><a href="#cb36-476" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**sum**: 0.85 (totale violazioni)</span>
<span id="cb36-477"><a href="#cb36-477" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**sum/#ac**: 2e-04 (molto basso)</span>
<span id="cb36-478"><a href="#cb36-478" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**zmax**: 4.27 (elevato, indica alcune violazioni significative)</span>
<span id="cb36-479"><a href="#cb36-479" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**#zsig**: 19 (violazioni statisticamente significative)</span>
<span id="cb36-480"><a href="#cb36-480" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**crit**: 84 (moderatamente alto)</span>
<span id="cb36-481"><a href="#cb36-481" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-482"><a href="#cb36-482" aria-hidden="true" tabindex="-1"></a>   L'item "reliable" sembra essere coerente con la scala ma ha un numero moderato di violazioni significative.</span>
<span id="cb36-483"><a href="#cb36-483" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-484"><a href="#cb36-484" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**unintelligent**</span>
<span id="cb36-485"><a href="#cb36-485" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**ItemH**: 0.12 (molto basso)</span>
<span id="cb36-486"><a href="#cb36-486" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**#ac**: 4608</span>
<span id="cb36-487"><a href="#cb36-487" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**#vi**: 12 (diverse violazioni)</span>
<span id="cb36-488"><a href="#cb36-488" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**#vi/#ac**: 0.00</span>
<span id="cb36-489"><a href="#cb36-489" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**maxvi**: 0.08</span>
<span id="cb36-490"><a href="#cb36-490" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**sum**: 0.50</span>
<span id="cb36-491"><a href="#cb36-491" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**sum/#ac**: 1e-04</span>
<span id="cb36-492"><a href="#cb36-492" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**zmax**: 4.55 (elevato)</span>
<span id="cb36-493"><a href="#cb36-493" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**#zsig**: 10</span>
<span id="cb36-494"><a href="#cb36-494" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**crit**: 82</span>
<span id="cb36-495"><a href="#cb36-495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-496"><a href="#cb36-496" aria-hidden="true" tabindex="-1"></a>   L'item "unintelligent" ha un indice di H molto basso e molte violazioni significative, indicando forti problemi di scalabilità.</span>
<span id="cb36-497"><a href="#cb36-497" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-498"><a href="#cb36-498" aria-hidden="true" tabindex="-1"></a>In sintesi, per interpretare questi risultati:</span>
<span id="cb36-499"><a href="#cb36-499" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-500"><a href="#cb36-500" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Gli item con valori alti di **ItemH** (sopra 0.3) sono generalmente buoni, ma devono essere esaminati anche in termini di violazioni.</span>
<span id="cb36-501"><a href="#cb36-501" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Gli item con molte violazioni (**#vi**), un alto valore di **#vi/#ac**, un alto **maxvi**, un alto **zmax**, e un alto **#zsig** indicano problemi di scalabilità e potrebbero necessitare di revisione o rimozione.</span>
<span id="cb36-502"><a href="#cb36-502" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Gli item contrassegnati con un asterisco (*) presentano generalmente più problemi.</span>
<span id="cb36-503"><a href="#cb36-503" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-504"><a href="#cb36-504" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-505"><a href="#cb36-505" aria-hidden="true" tabindex="-1"></a><span class="fu">### Indipendenza Locale</span></span>
<span id="cb36-506"><a href="#cb36-506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-507"><a href="#cb36-507" aria-hidden="true" tabindex="-1"></a>La funzione <span class="in">`check.iio()`</span> del pacchetto <span class="in">`mokken`</span> è utilizzata per verificare la proprietà di indipendenza locale degli item (Item Independence Order, IIO) in una scala di Mokken. Questa proprietà implica che la probabilità di rispondere correttamente a un item non dovrebbe dipendere dalle risposte ad altri item, se si tiene conto della posizione del soggetto sulla scala latente.</span>
<span id="cb36-508"><a href="#cb36-508" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-511"><a href="#cb36-511" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb36-512"><a href="#cb36-512" aria-hidden="true" tabindex="-1"></a>iio.list <span class="ot">&lt;-</span> <span class="fu">check.iio</span>(Communality)</span>
<span id="cb36-513"><a href="#cb36-513" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(iio.list)</span>
<span id="cb36-514"><a href="#cb36-514" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-515"><a href="#cb36-515" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-516"><a href="#cb36-516" aria-hidden="true" tabindex="-1"></a>L'output della funzione <span class="in">`check.iio()`</span> fornisce informazioni riguardanti la coerenza e la qualità degli item rispetto alla proprietà di indipendenza locale. </span>
<span id="cb36-517"><a href="#cb36-517" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-518"><a href="#cb36-518" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**ItemH**: Indice di scalabilità H per ciascun item. Valori più alti indicano una migliore coerenza con la scala.</span>
<span id="cb36-519"><a href="#cb36-519" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**#ac**: Numero di casi esaminati per ciascun item.</span>
<span id="cb36-520"><a href="#cb36-520" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**#vi**: Numero di violazioni della proprietà IIO per l'item.</span>
<span id="cb36-521"><a href="#cb36-521" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**#vi/#ac**: Proporzione di violazioni rispetto al numero di casi esaminati. Valori più bassi indicano migliori proprietà di indipendenza locale.</span>
<span id="cb36-522"><a href="#cb36-522" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>**maxvi**: La massima violazione osservata della proprietà IIO per l'item. Valori più alti indicano maggiori problemi.</span>
<span id="cb36-523"><a href="#cb36-523" aria-hidden="true" tabindex="-1"></a><span class="ss">6. </span>**sum**: Somma delle violazioni della proprietà IIO.</span>
<span id="cb36-524"><a href="#cb36-524" aria-hidden="true" tabindex="-1"></a><span class="ss">7. </span>**sum/#ac**: Proporzione della somma delle violazioni rispetto al numero di casi esaminati.</span>
<span id="cb36-525"><a href="#cb36-525" aria-hidden="true" tabindex="-1"></a><span class="ss">8. </span>**tmax**: Valore massimo della statistica T per le violazioni dell'IIO.</span>
<span id="cb36-526"><a href="#cb36-526" aria-hidden="true" tabindex="-1"></a><span class="ss">9. </span>**#tsig**: Numero di valori T significativi. Indica quante delle violazioni sono statisticamente significative.</span>
<span id="cb36-527"><a href="#cb36-527" aria-hidden="true" tabindex="-1"></a><span class="ss">10. </span>**crit**: Un valore critico che combina vari indicatori per valutare la qualità dell'item. Valori più alti possono indicare problemi con l'item.</span>
<span id="cb36-528"><a href="#cb36-528" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-529"><a href="#cb36-529" aria-hidden="true" tabindex="-1"></a>Esempio di interpretazione degli item.</span>
<span id="cb36-530"><a href="#cb36-530" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-531"><a href="#cb36-531" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**unintelligent**</span>
<span id="cb36-532"><a href="#cb36-532" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**ItemH**: 0.12 (basso, indica che l'item non è molto coerente con la scala).</span>
<span id="cb36-533"><a href="#cb36-533" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**#ac**: 26</span>
<span id="cb36-534"><a href="#cb36-534" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**#vi**: 2 (alcune violazioni).</span>
<span id="cb36-535"><a href="#cb36-535" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**#vi/#ac**: 0.08 (proporzione moderata di violazioni).</span>
<span id="cb36-536"><a href="#cb36-536" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**maxvi**: 0.15 (violazione massima moderata).</span>
<span id="cb36-537"><a href="#cb36-537" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**sum**: 0.29 (violazioni totali moderate).</span>
<span id="cb36-538"><a href="#cb36-538" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**sum/#ac**: 0.0112 (proporzione di violazioni relativamente alta).</span>
<span id="cb36-539"><a href="#cb36-539" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**tmax**: 2.16 (violazione significativa).</span>
<span id="cb36-540"><a href="#cb36-540" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**#tsig**: 1 (una violazione significativa).</span>
<span id="cb36-541"><a href="#cb36-541" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**crit**: 74 (alto, indica problemi significativi).</span>
<span id="cb36-542"><a href="#cb36-542" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-543"><a href="#cb36-543" aria-hidden="true" tabindex="-1"></a>L'item "unintelligent" presenta problemi significativi di indipendenza locale.</span>
<span id="cb36-544"><a href="#cb36-544" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-545"><a href="#cb36-545" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**dependable**</span>
<span id="cb36-546"><a href="#cb36-546" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**ItemH**: 0.30 (buono).</span>
<span id="cb36-547"><a href="#cb36-547" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**#ac**: 27</span>
<span id="cb36-548"><a href="#cb36-548" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**#vi**: 0 (nessuna violazione).</span>
<span id="cb36-549"><a href="#cb36-549" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**#vi/#ac**: 0.00</span>
<span id="cb36-550"><a href="#cb36-550" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**maxvi**: 0.00</span>
<span id="cb36-551"><a href="#cb36-551" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**sum**: 0.00</span>
<span id="cb36-552"><a href="#cb36-552" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**sum/#ac**: 0.0000</span>
<span id="cb36-553"><a href="#cb36-553" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**tmax**: 0.00</span>
<span id="cb36-554"><a href="#cb36-554" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**#tsig**: 0</span>
<span id="cb36-555"><a href="#cb36-555" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**crit**: 0</span>
<span id="cb36-556"><a href="#cb36-556" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-557"><a href="#cb36-557" aria-hidden="true" tabindex="-1"></a>L'item "dependable" non presenta violazioni della proprietà di indipendenza locale ed è altamente coerente con la scala.</span>
<span id="cb36-558"><a href="#cb36-558" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-559"><a href="#cb36-559" aria-hidden="true" tabindex="-1"></a>La sezione <span class="in">`backward.selection`</span> mostra il risultato della selezione all'indietro per identificare gli item problematici. Ogni colonna rappresenta un passaggio del processo di selezione:</span>
<span id="cb36-560"><a href="#cb36-560" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-561"><a href="#cb36-561" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**0**: L'item è mantenuto.</span>
<span id="cb36-562"><a href="#cb36-562" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**1**: L'item è stato rimosso a questo passaggio.</span>
<span id="cb36-563"><a href="#cb36-563" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-564"><a href="#cb36-564" aria-hidden="true" tabindex="-1"></a>Esempio di interpretazione:</span>
<span id="cb36-565"><a href="#cb36-565" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-566"><a href="#cb36-566" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**unintelligent**: Rimosso al passo 1.</span>
<span id="cb36-567"><a href="#cb36-567" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**honest**: Rimosso al passo 1 e mantenuto al passo 2.</span>
<span id="cb36-568"><a href="#cb36-568" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**deceitful**: Rimosso al passo 1 e mantenuto al passo 2.</span>
<span id="cb36-569"><a href="#cb36-569" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-570"><a href="#cb36-570" aria-hidden="true" tabindex="-1"></a>Infine, l'indice HT è una misura della forza della struttura di scala di Mokken. Un valore più alto indica una struttura più forte. In questo caso, un valore di 0.07338353 è relativamente basso, indicando che la struttura della scala potrebbe non essere molto forte.</span>
<span id="cb36-571"><a href="#cb36-571" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-572"><a href="#cb36-572" aria-hidden="true" tabindex="-1"></a>In conclusione, la funzione <span class="in">`check.iio()`</span> aiuta a identificare gli item che non soddisfano la proprietà di indipendenza locale in una scala di Mokken. Gli item con molte violazioni e un alto valore di crit sono problematici e potrebbero dover essere rivisti o rimossi. Il processo di selezione all'indietro aiuta a identificare questi item e a migliorare la qualità complessiva della scala.</span>
<span id="cb36-573"><a href="#cb36-573" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-574"><a href="#cb36-574" aria-hidden="true" tabindex="-1"></a><span class="fu">### Affidabilità</span></span>
<span id="cb36-575"><a href="#cb36-575" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-576"><a href="#cb36-576" aria-hidden="true" tabindex="-1"></a>La funzione <span class="in">`check.reliability()`</span> del pacchetto <span class="in">`mokken`</span> è utilizzata per valutare l'affidabilità di una scala psicometrica. L'affidabilità è una misura della coerenza interna degli item di una scala e indica quanto gli item misurano coerentemente lo stesso costrutto.</span>
<span id="cb36-577"><a href="#cb36-577" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-578"><a href="#cb36-578" aria-hidden="true" tabindex="-1"></a>Questa funzione calcola diversi indici di affidabilità, inclusi il coefficiente di scalabilità di Mokken, l'alpha di Cronbach e il lambda-2 di Guttman.</span>
<span id="cb36-579"><a href="#cb36-579" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-580"><a href="#cb36-580" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-583"><a href="#cb36-583" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb36-584"><a href="#cb36-584" aria-hidden="true" tabindex="-1"></a><span class="fu">check.reliability</span>(Communality)</span>
<span id="cb36-585"><a href="#cb36-585" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-586"><a href="#cb36-586" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-587"><a href="#cb36-587" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Il coefficiente di scalabilità di Mokken (MS) misura la forza della struttura di scala non parametrica degli item. Un valore più alto indica una scala più forte e coerente. Valori sopra 0.3 sono considerati accettabili, mentre valori sopra 0.5 indicano una buona scalabilità. Un valore di 0.7585348 suggerisce una scala molto forte e ben strutturata.</span>
<span id="cb36-588"><a href="#cb36-588" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>L'alpha di Cronbach è una misura comune della coerenza interna di una scala. Essa valuta quanto bene gli item della scala misurano lo stesso costrutto. Valori di alpha sopra 0.7 sono considerati accettabili, mentre valori sopra 0.8 sono considerati buoni. Un valore di 0.7465871 indica una buona coerenza interna della scala, sebbene sia leggermente inferiore alla soglia di eccellenza di 0.8.</span>
<span id="cb36-589"><a href="#cb36-589" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Il lambda-2 di Guttman è un altro indice di affidabilità che può essere più robusto dell'alpha di Cronbach in alcune circostanze. Valori più alti indicano maggiore affidabilità. Un valore di 0.7568063 è simile all'alpha di Cronbach e suggerisce una buona affidabilità.</span>
<span id="cb36-590"><a href="#cb36-590" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-591"><a href="#cb36-591" aria-hidden="true" tabindex="-1"></a>Nel complesso, i risultati indicano che la scala può essere considerata affidabile per la misurazione del costrutto in esame. Tuttavia, potrebbe esserci spazio per migliorare leggermente l'alpha di Cronbach per ottenere una coerenza interna ancora migliore.</span>
<span id="cb36-592"><a href="#cb36-592" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-593"><a href="#cb36-593" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-594"><a href="#cb36-594" aria-hidden="true" tabindex="-1"></a><span class="fu">### Automated Item Selection Procedure</span></span>
<span id="cb36-595"><a href="#cb36-595" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-596"><a href="#cb36-596" aria-hidden="true" tabindex="-1"></a>La funzione <span class="in">`aisp()`</span> del pacchetto <span class="in">`mokken`</span> in R viene utilizzata per identificare i pattern di item (Item Scalability Patterns) che soddisfano specifici criteri di scalabilità all'interno di una scala. Essa aiuta a determinare quali item contribuiscono alla struttura scalare della scala di Mokken.</span>
<span id="cb36-597"><a href="#cb36-597" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-598"><a href="#cb36-598" aria-hidden="true" tabindex="-1"></a><span class="in">`aisp()`</span> sta per "Automated Item Selection Procedure" ed è una procedura automatizzata per la selezione degli item che meglio soddisfano i criteri di scalabilità definiti dall'utente.</span>
<span id="cb36-599"><a href="#cb36-599" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-602"><a href="#cb36-602" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb36-603"><a href="#cb36-603" aria-hidden="true" tabindex="-1"></a><span class="fu">aisp</span>(Communality, <span class="at">lowerbound =</span> <span class="fl">0.3</span>)</span>
<span id="cb36-604"><a href="#cb36-604" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-605"><a href="#cb36-605" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-606"><a href="#cb36-606" aria-hidden="true" tabindex="-1"></a>L'output di <span class="in">`aisp()`</span> mostra i pattern di scalabilità degli item. Gli item sono valutati in base alla loro capacità di soddisfare il criterio di scalabilità. </span>
<span id="cb36-607"><a href="#cb36-607" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-608"><a href="#cb36-608" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**0.3**: Questo rappresenta la soglia di scalabilità (H) utilizzata nella selezione degli item.</span>
<span id="cb36-609"><a href="#cb36-609" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Valori associati agli item**:</span>
<span id="cb36-610"><a href="#cb36-610" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**1**: L'item soddisfa il criterio di scalabilità con un coefficiente H superiore a 0.3.</span>
<span id="cb36-611"><a href="#cb36-611" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**0**: L'item non soddisfa il criterio di scalabilità con un coefficiente H inferiore a 0.3.</span>
<span id="cb36-612"><a href="#cb36-612" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>**2**: L'item è considerato problematico, probabilmente per la presenza di molteplici violazioni della monotonicità o altre problematiche di scalabilità.</span>
<span id="cb36-613"><a href="#cb36-613" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-614"><a href="#cb36-614" aria-hidden="true" tabindex="-1"></a>Dettaglio degli item</span>
<span id="cb36-615"><a href="#cb36-615" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-616"><a href="#cb36-616" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**reliable**: 1</span>
<span id="cb36-617"><a href="#cb36-617" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Questo item soddisfa il criterio di scalabilità e ha un coefficiente H superiore a 0.3.</span>
<span id="cb36-618"><a href="#cb36-618" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb36-619"><a href="#cb36-619" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**honest**: 1</span>
<span id="cb36-620"><a href="#cb36-620" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Anche questo item soddisfa il criterio di scalabilità con un coefficiente H superiore a 0.3.</span>
<span id="cb36-621"><a href="#cb36-621" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb36-622"><a href="#cb36-622" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**unscrupulous**: 0</span>
<span id="cb36-623"><a href="#cb36-623" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Questo item non soddisfa il criterio di scalabilità, avendo un coefficiente H inferiore a 0.3.</span>
<span id="cb36-624"><a href="#cb36-624" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb36-625"><a href="#cb36-625" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**deceitful**: 1</span>
<span id="cb36-626"><a href="#cb36-626" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Questo item soddisfa il criterio di scalabilità con un coefficiente H superiore a 0.3.</span>
<span id="cb36-627"><a href="#cb36-627" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb36-628"><a href="#cb36-628" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>**unintelligent**: 0</span>
<span id="cb36-629"><a href="#cb36-629" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Questo item non soddisfa il criterio di scalabilità, avendo un coefficiente H inferiore a 0.3.</span>
<span id="cb36-630"><a href="#cb36-630" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb36-631"><a href="#cb36-631" aria-hidden="true" tabindex="-1"></a><span class="ss">6. </span>**obnoxious**: 2</span>
<span id="cb36-632"><a href="#cb36-632" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Questo item è problematico e non soddisfa completamente il criterio di scalabilità, probabilmente a causa di violazioni della monotonicità.</span>
<span id="cb36-633"><a href="#cb36-633" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb36-634"><a href="#cb36-634" aria-hidden="true" tabindex="-1"></a><span class="ss">7. </span>**thankless**: 2</span>
<span id="cb36-635"><a href="#cb36-635" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Anche questo item è problematico e non soddisfa completamente il criterio di scalabilità, con possibili violazioni della monotonicità.</span>
<span id="cb36-636"><a href="#cb36-636" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb36-637"><a href="#cb36-637" aria-hidden="true" tabindex="-1"></a><span class="ss">8. </span>**unfriendly**: 2</span>
<span id="cb36-638"><a href="#cb36-638" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Questo item è problematico e presenta molteplici violazioni della monotonicità, quindi non soddisfa il criterio di scalabilità.</span>
<span id="cb36-639"><a href="#cb36-639" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb36-640"><a href="#cb36-640" aria-hidden="true" tabindex="-1"></a><span class="ss">9. </span>**dependable**: 1</span>
<span id="cb36-641"><a href="#cb36-641" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Questo item soddisfa il criterio di scalabilità con un coefficiente H superiore a 0.3.</span>
<span id="cb36-642"><a href="#cb36-642" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb36-643"><a href="#cb36-643" aria-hidden="true" tabindex="-1"></a><span class="ss">10. </span>**cruel**: 2</span>
<span id="cb36-644"><a href="#cb36-644" aria-hidden="true" tabindex="-1"></a><span class="ss">    - </span>Questo item è problematico e non soddisfa completamente il criterio di scalabilità, con possibili violazioni della monotonicità.</span>
<span id="cb36-645"><a href="#cb36-645" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-646"><a href="#cb36-646" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-647"><a href="#cb36-647" aria-hidden="true" tabindex="-1"></a>L'output della funzione <span class="in">`aisp()`</span> aiuta a identificare quali item in una scala di Mokken soddisfano i criteri di scalabilità e quali no. Gli item con valore **1** sono quelli che soddisfano il criterio di scalabilità (H &gt; 0.3), mentre quelli con valore **0** non lo soddisfano. Gli item con valore **2** sono considerati problematici e potrebbero necessitare di revisione o rimozione dalla scala. Utilizzare queste informazioni per migliorare la qualità complessiva della scala, garantendo che solo gli item con buone proprietà di scalabilità siano inclusi.</span>
<span id="cb36-648"><a href="#cb36-648" aria-hidden="true" tabindex="-1"></a></span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>